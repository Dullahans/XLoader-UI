<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title></title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Noto+Sans+SC:wght@300;400;500;600;700&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://unpkg.com/element-ui@2.15.14/lib/theme-chalk/index.css"><script src="https://unpkg.com/vue@2.7.14/dist/vue.min.js"></script><script src="https://unpkg.com/element-ui@2.15.14/lib/index.js"></script><style>:root {
      --primary-color: #2563eb;
      --primary-dark: #1d4ed8;
      --primary-light: #3b82f6;
      --primary-bg: rgba(37, 99, 235, 0.08);
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --info-color: #6366f1;
      --running-color: #8b5cf6;
      --bg-page: #f8fafc;
      --bg-white: #ffffff;
      --bg-gray: #f1f5f9;
      --bg-hover: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --border-color: #e2e8f0;
      --border-light: #f1f5f9;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --font-sans: 'Noto Sans SC', -apple-system, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      /*  1.5 260px -> 390px */
      --sidebar-width: 390px;
      --toolbar-height: 52px;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: var(--font-sans); font-size: 14px; color: var(--text-primary); background: var(--bg-page); }
    #app { height: 100%; }

    .app-layout { display: flex; height: 100%; }

    /* 豸 */
    .device-sidebar {
      width: var(--sidebar-width);
      background: var(--bg-white);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-color);
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar-title {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      user-select: none;
    }

    .ws-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
      margin-left: auto;
      transition: all 0.3s;
    }

    .ws-indicator.connected {
      background: var(--success-color);
      box-shadow: 0 0 6px var(--success-color);
    }

    .sidebar-section {
      padding: 12px 12px 8px;
      border-bottom: 1px solid var(--border-color);
    }
    .sidebar-section .section-title {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .sidebar-scroll {
      flex: 1;
      overflow: auto;
      padding: 12px;
    }

    .empty-hint {
      padding: 14px 12px;
      border: 1px dashed var(--border-color);
      border-radius: 10px;
      background: var(--bg-gray);
      color: var(--text-secondary);
      text-align: center;
      font-size: 12px;
    }
    .empty-hint .muted { margin-top: 4px; color: var(--text-muted); font-size: 11px; }

    .lab-block { margin-bottom: 14px; }
    .lab-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .lab-name { font-weight: 600; color: var(--text-primary); }
    .lab-count { font-size: 11px; color: var(--text-muted); }

    .cabinet-card {
      border: 1px solid var(--border-color);
      border-radius: 12px;
      background: var(--bg-white);
      overflow: hidden;
      margin-bottom: 0;
      box-shadow: var(--shadow-sm);
    }

    .cabinet-img {
      position: relative;
      background: var(--bg-gray);
      padding: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    .cabinet-img img {
      width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 10px;
      display: block;
    }
    .cabinet-ip {
      position: absolute;
      top: 14px;
      left: 14px;
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border-color);
      padding: 2px 6px;
      border-radius: 6px;
    }

    .cabinet-block { margin-bottom: 12px; }

    /* 豸壺6 */
    .cabinet-stack {
      position: relative;
      height: 190px; /* 峤 */
      margin-top: 8px;
    }

    /* LOGO / IP /  */
    .cabinet-frame {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border-color);
      background: var(--bg-gray);
      box-shadow: var(--shadow-sm);
      display: grid;
      grid-template-rows: 44px 34px 1fr;
    }
    .cabinet-frame-bg {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    .cabinet-frame-bg img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .cabinet-row {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      padding: 0 10px;
      border-bottom: 1px solid rgba(226, 232, 240, 0.8);
      gap: 8px;
    }
    .cabinet-row.logo {
      background: rgba(15, 23, 42, 0.86);
      border-bottom: 1px solid rgba(31, 41, 55, 0.7);
    }
    .cabinet-row.ip {
      background: rgba(241, 245, 249, 0.95);
    }
    .cabinet-logo {
      height: 22px;
      width: auto;
      display: block;
    }
    .cabinet-ip-text {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-primary);
    }
    .cabinet-body {
      position: relative;
      z-index: 1;
      padding: 8px 10px 10px;
    }

    /* 壺6 */
    .cabinet-device-grid {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 2px;
      align-items: end;
    }

    .device-item { text-align: center; }
    .device-pic {
      position: relative;
      width: 58px;     /*  */
      height: 78px;
      margin: 0 auto;
    }
    .device-item.selected .device-pic {
      border-radius: 10px;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.55), 0 8px 18px rgba(37, 99, 235, 0.18);
      background: rgba(37, 99, 235, 0.06);
    }
    .device-item.selected .device-model {
      color: var(--primary-color);
      font-weight: 600;
    }
    .device-pic img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    .rgb-dot {
      position: absolute;
      bottom: 6px;     /*  */
      right: 6px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #94a3b8; /* default  */
      box-shadow: none;
      border: 2px solid rgba(255,255,255,0.95); /*  */
      outline: 1px solid rgba(0,0,0,0.18);
    }
    .rgb-dot.connected { background: #22c55e; box-shadow: 0 0 8px rgba(34, 197, 94, 0.55); }
    .rgb-dot.running { background: #3b82f6; box-shadow: 0 0 8px rgba(59, 130, 246, 0.55); }
    .rgb-dot.alarm { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.55); }
    .rgb-dot.upgrading {
      animation: ota-blink 500ms infinite;
    }
    @keyframes ota-blink {
      0%, 50% { background: #3b82f6; box-shadow: 0 0 8px rgba(59, 130, 246, 0.55); }
      25%, 75% { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.55); }
    }
    .device-index {
      position: absolute;
      bottom: 4px;
      left: 4px;
      font-family: var(--font-mono);
      font-size: 11px;
      color: #fff;
      background: rgba(15, 23, 42, 0.75);
      padding: 1px 5px;
      border-radius: 6px;
    }
    .device-model {
      margin-top: 4px;
      font-size: 10px;
      color: var(--text-secondary);
      white-space: normal;     /*  */
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;   /*  */
      -webkit-box-orient: vertical;
      line-height: 1.2;
      min-height: calc(1.2em * 2);
    }

    .device-card {
      margin: 12px;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      overflow: hidden;
    }

    .device-visual {
      height: 140px;
      background: linear-gradient(180deg, #dbeafe 0%, #bfdbfe 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .device-image {
      width: 120px;
      height: 90px;
      background: linear-gradient(145deg, #374151 0%, #1f2937 100%);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
    }

    .device-screen {
      width: 80px;
      height: 36px;
      background: #000;
      border-radius: 3px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-mono);
      font-size: 14px;
      color: #00ff88;
      text-shadow: 0 0 8px #00ff88;
    }

    .device-leds { display: flex; gap: 6px; }
    .led { width: 6px; height: 6px; border-radius: 50%; background: #333; }
    .led.power { background: var(--success-color); box-shadow: 0 0 6px var(--success-color); }
    .led.run { background: var(--primary-light); box-shadow: 0 0 6px var(--primary-light); animation: blink 1s infinite; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    .device-info { padding: 12px; }
    .device-name { font-size: 14px; font-weight: 600; margin-bottom: 6px; }
    .device-sn { 
      font-size: 11px; 
      color: var(--primary-color); 
      font-family: var(--font-mono); 
      background: var(--primary-bg);
      padding: 2px 6px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 8px;
    }
    .device-meta { font-size: 12px; color: var(--text-muted); }
    .meta-row { display: flex; justify-content: space-between; padding: 2px 0; }
    .meta-value { font-family: var(--font-mono); color: var(--text-secondary); }

    .connection-status {
      margin: 0 12px 12px;
      padding: 10px 12px;
      background: var(--bg-gray);
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); }
    .status-indicator.connected { background: var(--success-color); box-shadow: 0 0 6px var(--success-color); }
    .status-text { flex: 1; }
    .status-title { font-size: 12px; font-weight: 500; }
    .status-desc { font-size: 10px; color: var(--text-muted); }

    .connect-btn { margin: 0 12px 12px; }
    .connect-btn .el-button { width: 100%; }

    .running-model {
      margin: 0 12px 12px;
      padding: 10px 12px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 6px;
    }

    .running-model-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }

    .running-model-header i {
      color: var(--running-color);
      animation: pulse 2s infinite;
    }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    .running-model-title { font-size: 11px; font-weight: 500; color: var(--running-color); }
    .running-model-info { font-size: 12px; }
    .running-file { font-family: var(--font-mono); color: var(--text-primary); font-weight: 500; }
    .running-module { font-size: 11px; color: var(--text-secondary); margin-top: 2px; }

    .run-status { margin: 0 12px 12px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; }
    .run-status-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 12px; }
    .run-badge { padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: 500; }
    .run-badge.running { background: rgba(16, 185, 129, 0.1); color: var(--success-color); }
    .run-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
    .stat-box { background: var(--bg-gray); padding: 6px; border-radius: 4px; text-align: center; }
    .stat-value { font-size: 14px; font-weight: 600; font-family: var(--font-mono); }
    .stat-label { font-size: 9px; color: var(--text-muted); }

    /*  */
    .main-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }

    .toolbar {
      height: var(--toolbar-height);
      background: var(--bg-white);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 8px;
    }

    .toolbar-title { font-size: 16px; font-weight: 600; margin-right: 20px; }
    .toolbar-buttons { display: flex; gap: 6px; flex: 1; }

    .tool-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 6px 12px;
      background: var(--bg-gray);
      border: 1px solid transparent;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .tool-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .tool-btn.active { background: var(--primary-bg); color: var(--primary-color); border-color: var(--primary-color); }
    .tool-btn i { font-size: 14px; }

    .content-area { flex: 1; display: flex; flex-direction: column; padding: 16px 20px; overflow: hidden; }

    /* 豸 */
    .upgrade-panel {
      background: var(--bg-white);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-sm);
      padding: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .upgrade-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .upgrade-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .upgrade-hint { font-size: 12px; color: var(--text-muted); }
    .upgrade-list {
      flex: 1;
      overflow: auto;
      border-top: 1px solid var(--border-light);
      padding-top: 10px;
    }
    .ota-ip-block { margin-bottom: 14px; }
    .ota-ip-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .ota-ip {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text-primary);
      font-weight: 700;
    }
    .ota-device-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .ota-device-card {
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .ota-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .ota-name { font-weight: 700; font-size: 12px; color: var(--text-primary); }
    .ota-meta { font-size: 11px; color: var(--text-secondary); font-family: var(--font-mono); }
    .ota-status { font-size: 11px; color: var(--text-muted); }

    /* 豸// */
    .model-control-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      background: var(--bg-white);
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: var(--shadow-sm);
    }
    .model-control-bar .bar-left,
    .model-control-bar .bar-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .model-control-bar .bar-label {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .page-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
      background: var(--bg-white);
      padding: 3px;
      border-radius: 8px;
      width: fit-content;
      box-shadow: var(--shadow-sm);
    }

    .page-tab {
      padding: 6px 16px;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .page-tab:hover { color: var(--text-primary); background: var(--bg-gray); }
    .page-tab.active { color: var(--primary-color); background: var(--primary-bg); }

    .page-content {
      flex: 1;
      background: var(--bg-white);
      border-radius: 10px;
      box-shadow: var(--shadow-sm);
      overflow: hidden;
      display: none;
    }

    .page-content.active { display: flex; flex-direction: column; }

    .page-header {
      padding: 12px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .page-title { font-size: 15px; font-weight: 600; }
    
    .btn-group { display: flex; gap: 8px; align-items: center; }
    .btn-divider { width: 1px; height: 20px; background: var(--border-color); margin: 0 4px; }

    .action-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-white);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .action-btn:hover { border-color: var(--primary-color); color: var(--primary-color); background: var(--primary-bg); }
    .action-btn.primary { background: var(--primary-color); border-color: var(--primary-color); color: white; }
    .action-btn.primary:hover { background: var(--primary-dark); }
    .action-btn.success { background: var(--success-color); border-color: var(--success-color); color: white; }
    .action-btn.success:hover { background: #059669; }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
    .action-btn i { font-size: 14px; }

    .page-body { flex: 1; padding: 16px 20px; overflow-y: auto; }

    /*  */
    .model-layout { display: flex; gap: 16px; height: 100%; }

    .model-list {
      width: 220px;
      flex-shrink: 0;
      border-right: 1px solid var(--border-color);
      padding-right: 16px;
      display: flex;
      flex-direction: column;
    }

    .model-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .sn-badge {
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--primary-color);
      background: var(--primary-bg);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .model-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 4px;
      border: 1px solid transparent;
      position: relative;
    }

    .model-item:hover { background: var(--bg-gray); }
    .model-item.active { background: var(--primary-bg); border-color: var(--primary-color); }
    .model-item.has-error { border-color: var(--error-color); background: rgba(239, 68, 68, 0.05); }
    
    .model-item.is-running {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(139, 92, 246, 0.08) 100%);
      border-color: var(--running-color);
    }

    .model-item.is-running::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: var(--running-color);
      border-radius: 3px 0 0 3px;
    }

    .model-item i { color: var(--text-muted); font-size: 16px; }
    .model-item.active i { color: var(--primary-color); }
    .model-item.is-running i { color: var(--running-color); }
    .model-item-info { flex: 1; min-width: 0; }
    .model-item-name { font-size: 12px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .model-item-size { font-size: 10px; color: var(--text-muted); }
    .model-item-badge { font-size: 9px; padding: 1px 4px; border-radius: 3px; }
    .model-item-badge.running { background: var(--running-color); color: white; }

      .model-item-btns, .module-btns {
        display: none;
        margin-left: 4px;
      }
      .model-item:hover .model-item-btns, .module-header:hover .module-btns {
        display: block;
      }
      .delete-btn { color: var(--error-color) !important; padding: 0 !important; }
      .delete-btn:hover { color: #fecaca !important; }

    .model-editor { flex: 1; display: flex; flex-direction: column; min-width: 0; }

    .editor-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .editor-filename {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 500;
    }

    .editor-filename i { color: var(--primary-color); }
    .modified-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--warning-color); }

    /*  */
    .module-section {
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .module-section.is-running {
      border-color: var(--running-color);
      box-shadow: 0 0 0 1px rgba(139, 92, 246, 0.2);
    }

    .module-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-gray);
      cursor: pointer;
      transition: background 0.2s;
    }

    .module-section.is-running .module-header {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(139, 92, 246, 0.08) 100%);
    }

    .module-header:hover { background: var(--bg-hover); }

    .module-toggle {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    .module-toggle.expanded { transform: rotate(90deg); }

    .module-info { flex: 1; }
    
    .module-name-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .module-name {
      font-size: 13px;
      font-weight: 600;
      font-family: var(--font-mono);
      color: var(--primary-color);
    }

    .module-section.is-running .module-name { color: var(--running-color); }

    .module-name-cn {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: normal;
    }

    .module-desc {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .module-count {
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-white);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .running-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--running-color);
      background: rgba(139, 92, 246, 0.15);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .running-indicator i { animation: blink 1s infinite; }

    .module-body { display: none; padding: 12px 14px; }
    .module-body.expanded { display: block; }

    /*  -  */
    .param-row {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 12px;
      align-items: start;
      padding: 10px 12px;
      border-radius: 6px;
      margin-bottom: 4px;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .param-row:hover { 
      background: var(--bg-gray); 
      border-color: var(--border-color);
    }

    .param-label-section {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .param-name-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .param-key {
      font-size: 12px;
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 500;
    }

    .param-name-cn {
      font-size: 11px;
      color: var(--primary-color);
      background: var(--primary-bg);
      padding: 1px 6px;
      border-radius: 4px;
    }

    .param-desc {
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .param-range {
      font-size: 10px;
      color: var(--text-muted);
      font-family: var(--font-mono);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .param-range i {
      font-size: 12px;
      color: var(--info-color);
    }

    .param-input-section {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .param-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .param-unit {
      font-size: 11px;
      color: var(--text-muted);
      font-family: var(--font-mono);
      min-width: 40px;
    }

    .param-type-badge {
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 3px;
      background: var(--bg-gray);
      color: var(--text-muted);
    }

    /*  */
    .param-row.out-of-range {
      border-color: var(--warning-color);
      background: rgba(245, 158, 11, 0.05);
    }

    .range-warning {
      font-size: 10px;
      color: var(--warning-color);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /*  */
    .array-display {
      background: var(--bg-gray);
      border-radius: 6px;
      padding: 10px;
      width: 100%;
    }

    .array-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border-color);
    }

    .array-label {
      font-size: 11px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .array-items {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .array-item {
      display: flex;
      align-items: center;
      gap: 4px;
      background: var(--bg-white);
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

    .array-index {
      font-size: 10px;
      color: var(--text-muted);
      font-family: var(--font-mono);
      min-width: 24px;
    }

    .array-item .el-input-number { width: 90px; }
    .array-item .el-input { width: 80px; }
    .array-item .el-button { padding: 2px; color: var(--text-muted); }
    .array-item .el-button:hover { color: var(--error-color); }

    /*  */
    .matrix-display {
      background: var(--bg-gray);
      border-radius: 6px;
      padding: 10px;
      width: 100%;
    }

    .matrix-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border-color);
    }

    .matrix-size {
      font-size: 11px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .matrix-table {
      overflow-x: auto;
    }

    .matrix-header {
      display: flex;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 6px;
    }

    .matrix-header-cell {
      width: 80px;
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      font-weight: 500;
      flex-shrink: 0;
    }

    .matrix-row {
      display: flex;
      gap: 8px;
      padding: 4px 0;
      align-items: center;
    }

    .matrix-row:hover {
      background: var(--bg-hover);
      margin: 0 -6px;
      padding: 4px 6px;
      border-radius: 4px;
    }

    .matrix-row-index {
      width: 24px;
      font-size: 10px;
      color: var(--text-muted);
      font-family: var(--font-mono);
      text-align: center;
      flex-shrink: 0;
    }

    .matrix-cell-input {
      width: 80px !important;
      flex-shrink: 0;
    }

    .matrix-action-cell {
      width: 24px;
      flex-shrink: 0;
    }

    .matrix-delete-btn {
      padding: 2px;
      color: var(--text-muted);
      opacity: 0;
      transition: opacity 0.2s;
    }

    .matrix-row:hover .matrix-delete-btn {
      opacity: 1;
    }

    .matrix-delete-btn:hover {
      color: var(--error-color);
    }

    /*  */
    .data-path {
      font-size: 11px;
      color: var(--text-muted);
      padding: 8px 12px;
      background: var(--bg-gray);
      border-radius: 6px;
      margin-bottom: 12px;
      font-family: var(--font-mono);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .data-path i { color: var(--primary-color); }

    /*  */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .empty-state i { font-size: 48px; margin-bottom: 12px; }
    .empty-state p { font-size: 13px; }

    /*  */
    .param-unknown {
      font-size: 10px;
      color: var(--text-muted);
      font-style: italic;
    }

    /* ============================================
       豸
    ============================================ */
    
    .device-overview-card {
      display: flex;
      gap: 24px;
      padding: 20px;
      background: var(--bg-white);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .device-photo {
      width: 280px;
      height: 200px;
      flex-shrink: 0;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      background: var(--bg-gray);
    }

    .device-photo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .device-photo-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      gap: 8px;
    }

    .device-photo-overlay i {
      font-size: 32px;
      color: var(--warning-color);
    }

    .device-overview-info {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .device-overview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .device-model-name {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .device-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .info-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .info-value {
      font-size: 14px;
      color: var(--text-primary);
      font-weight: 500;
    }

    .info-value.sn {
      font-family: var(--font-mono);
      color: var(--primary-color);
      background: var(--primary-bg);
      padding: 2px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .info-value.mono {
      font-family: var(--font-mono);
    }

    .info-value.highlight {
      color: var(--success-color);
    }

    .running-model-info {
      margin-top: auto;
      padding: 12px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 8px;
    }

    .running-model-info.stopped {
      background: var(--bg-gray);
      border-color: var(--border-color);
    }

    .running-model-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: var(--running-color);
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .running-model-badge i {
      animation: pulse 2s infinite;
    }

    .running-model-badge.stopped {
      background: var(--text-muted);
    }

    .running-model-badge.stopped i {
      animation: none;
    }

    .running-model-detail {
      display: flex;
      gap: 8px;
      font-size: 12px;
    }

    .running-label {
      color: var(--text-muted);
    }

    .running-value {
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 500;
    }

    /*  */
    .spec-section, .realtime-section {
      margin-bottom: 20px;
    }

    .section-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }

    .section-title i {
      color: var(--primary-color);
    }

    .spec-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }

    .spec-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg-white);
      border: 1px solid var(--border-color);
      border-radius: 10px;
    }

    .spec-icon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .spec-content {
      display: flex;
      flex-direction: column;
    }

    .spec-value {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      font-family: var(--font-mono);
    }

    .spec-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    /*  */
    .realtime-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }

    .realtime-card {
      padding: 16px;
      background: var(--bg-white);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      position: relative;
    }

    .realtime-value {
      font-size: 28px;
      font-weight: 600;
      color: var(--text-primary);
      font-family: var(--font-mono);
    }

    .realtime-unit {
      font-size: 14px;
      color: var(--text-muted);
      margin-left: 4px;
    }

    .realtime-label {
      display: block;
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .realtime-bar {
      height: 4px;
      background: var(--bg-gray);
      border-radius: 2px;
      margin-top: 12px;
      overflow: hidden;
    }

    .realtime-bar-fill {
      height: 100%;
      background: var(--primary-color);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* ============================================
       
    ============================================ */
    
    .register-page {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .register-filters {
      display: flex;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    .register-table-container {
      flex: 1;
      overflow: auto;
      margin-top: 12px;
    }

    .register-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .register-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .register-table th {
      background: var(--bg-gray);
      color: var(--text-secondary);
      font-weight: 500;
      text-align: left;
      padding: 10px 12px;
      border-bottom: 2px solid var(--border-color);
      white-space: nowrap;
    }

    .register-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border-light);
      vertical-align: middle;
    }

    .register-table tr:hover {
      background: var(--primary-bg);
    }

    .register-table tr.reg-modified {
      background: rgba(245, 158, 11, 0.08);
    }
    
    .register-table tr.reg-read-error {
      background: rgba(239, 68, 68, 0.06);
    }

    .reg-value.error {
      color: var(--error-color);
      font-weight: 600;
    }

    .reg-range {
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .reg-name {
      font-weight: 500;
      color: var(--text-primary);
    }

    .reg-desc {
      font-size: 12px;
      color: var(--text-muted);
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .reg-value-cell {
      min-width: 180px;
    }

    .reg-value {
      font-family: var(--font-mono);
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .reg-value.readonly {
      background: var(--bg-gray);
      color: var(--text-primary);
    }

    .reg-input-wrap {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .reg-current-value {
      font-size: 11px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .reg-input {
      padding: 6px 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: var(--font-mono);
      font-size: 13px;
      width: 100%;
      max-width: 180px;
      transition: all 0.2s;
    }

    .reg-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px var(--primary-bg);
    }

    .reg-input::placeholder {
      font-family: var(--font-sans);
      font-size: 12px;
      color: var(--text-muted);
    }

    .reg-actions {
      white-space: nowrap;
    }

    .reg-actions .el-button {
      padding: 5px 10px;
      font-size: 12px;
    }

    .register-stats {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      border-top: 1px solid var(--border-color);
      font-size: 12px;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    /*  */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-gray); }
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }

    /*  */
    .non-modal-drawer.el-drawer__wrapper {
      pointer-events: none;
      z-index: 2000;
    }
    .non-modal-drawer .el-drawer {
      pointer-events: auto;
      box-shadow: -2px 0 12px rgba(0,0,0,0.1);
    }
    /* 豸 */
    .cabinet-device-grid {
      position: relative;
      z-index: 1;
    }

    /*  Sheet  */
    .register-table tr[draggable="true"] {
      cursor: grab;
    }
    .register-table tr[draggable="true"]:active {
      cursor: grabbing;
    }
    .register-table tr.drag-over-row {
      border-top: 2px solid var(--primary-color);
    }
    
    /*  */
    .tab-label-zone {
      display: inline-block;
      height: 100%;
      padding: 0 10px;
      margin: 0 -15px; /*  */
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }
    .tab-label-zone.drag-over-tab {
      background-color: rgba(var(--primary-rgb), 0.1);
      box-shadow: inset 0 -2px 0 var(--primary-color);
    }
    .root-tab-label {
      color: var(--primary-color);
      font-weight: 800 !important;
    }
    .root-tab-label i {
      margin-right: 4px;
    }
    .el-tabs__item.is-active .root-tab-label {
      background: #eff6ff;
      border-radius: 4px 4px 0 0;
    }

    /*  */
    .context-menu {
      position: fixed;
      z-index: 3000;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      padding: 5px 0;
      min-width: 120px;
    }
    .context-menu-item {
      padding: 8px 12px;
      font-size: 12px;
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .context-menu-item:hover {
      background-color: var(--bg-gray);
      color: var(--primary-color);
    }
    .context-menu-item.danger:hover {
      background-color: #fef2f2;
      color: var(--danger-color);
    }
    .context-menu-divider {
      height: 1px;
      background-color: var(--border-color);
      margin: 4px 0;
    }
    .context-submenu {
      position: absolute;
      left: 100%;
      top: 0;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      padding: 5px 0;
      display: none;
      min-width: 120px;
    }
    .context-menu-item:hover > .context-submenu {
      display: block;
    }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }</style><link href="css/app.0e433876.css" rel="preload" as="style"><link href="css/chunk-vendors.d38403b9.css" rel="preload" as="style"><link href="js/app.dbff47d4.js" rel="preload" as="script"><link href="js/chunk-vendors.892de51e.js" rel="preload" as="script"><link href="css/chunk-vendors.d38403b9.css" rel="stylesheet"><link href="css/app.0e433876.css" rel="stylesheet"></head><body><div id="app"><div class="app-layout"><aside class="device-sidebar"><div class="sidebar-header"><span class="sidebar-title">X-Loader</span><el-tooltip :content="wsConnected ? 'WebSocket' : 'WebSocket'" placement="right"><span class="ws-indicator" :class="{ connected: wsConnected }"></span></el-tooltip></div><div class="sidebar-section"><div class="section-title"><span></span><el-tag v-if="!isLocationRegistered" size="mini" type="danger" effect="plain" style="font-weight: normal; transform: scale(0.85);"></el-tag></div><div style="display: flex; gap: 6px;"><el-select v-model="selectedLocation" size="mini" placeholder="" style="flex: 1;" @change="onLocationChanged"><el-option v-if="selectedLocation === '' && !isLocationRegistered" key="" label="" value="" disabled></el-option><el-option v-for="loc in locationList" :key="loc" :label="loc" :value="loc"></el-option></el-select><el-button size="mini" type="primary" icon="el-icon-check" circle @click="handleSaveLocation" title=""></el-button></div></div><div class="sidebar-scroll"><div v-if="!hasConnectStatus" class="empty-hint"><i class="el-icon-info"></i><div></div><div class="muted">get_connect_status</div></div><div v-for="lab in labView" :key="lab.labKey" class="lab-block"><div class="lab-header"><span class="lab-name">{{ lab.labKey }}</span> <span class="lab-count">{{ lab.cabinets.length }}</span></div><div v-for="cab in lab.cabinets" :key="cab.ip" class="cabinet-block"><div class="cabinet-stack"><div class="cabinet-frame"><div class="cabinet-frame-bg"><img src="img/cabinet.png" alt="cabinet"></div><div class="cabinet-row logo"><img class="cabinet-logo" src="img/logo.png" alt="logo"></div><div class="cabinet-row ip"><span class="cabinet-ip-text">IP: {{ cab.ip }}</span></div><div class="cabinet-body"><div class="cabinet-device-grid"><div v-for="dev in cab.devices" :key="dev.loader_num" class="device-item" :class="{ selected: isSelectedDevice(dev), disconnected: !toBool(dev.connect) }" @click="selectDevice(dev)" title="豸"><div class="device-pic"><img src="img/device.png" alt="device"> <span class="rgb-dot" :class="deviceLedClass(dev)"></span> <span class="device-index">{{ dev.loader_num + 1 }}</span></div><div class="device-model" :title="dev.loader_name || dev.running_model || ''">{{ dev.loader_name || dev.running_model || '' }}</div></div></div></div></div></div></div></div></div></aside><div class="main-area"><div class="toolbar"><div class="toolbar-buttons"><button class="tool-btn" @click="openUpgradeDialog"><i class="el-icon-upload"></i>豸</button> <button class="tool-btn" @click="openLogDialog"><i class="el-icon-document"></i></button> <button class="tool-btn" @click="openConsoleDrawer"><i class="el-icon-monitor"></i></button></div></div><div class="content-area"><div class="model-control-bar"><div class="bar-left"><span class="bar-label"></span><el-cascader v-model="selectedModelPath" :options="modelOptions" :props="{ expandTrigger: 'hover' }" size="mini" clearable placeholder="/" style="width: 320px;"></el-cascader><el-button size="mini" icon="el-icon-refresh" @click="refreshModelOptions" :loading="modelOptionsLoading"></el-button><el-radio-group v-model="runMode" size="mini" style="margin-left: 10px;" :disabled="isModelRunning"><el-radio-button label="model"></el-radio-button><el-radio-button label="regen"></el-radio-button></el-radio-group></div><div class="bar-right"><el-button size="mini" type="success" icon="el-icon-video-play" @click="startSelectedModel" :disabled="!canStartSelected"></el-button><el-button size="mini" type="danger" icon="el-icon-video-pause" @click="stopSelectedModel" :disabled="!canStopSelected"></el-button></div></div><div class="page-tabs"><button class="page-tab" :class="{ active: activePage === 'info' }" @click="activePage = 'info'">豸</button> <button class="page-tab" :class="{ active: activePage === 'model' }" @click="activePage = 'model'"></button> <button class="page-tab" :class="{ active: activePage === 'register' }" @click="activePage = 'register'"></button></div><el-dialog title="" :visible.sync="dialogModelVisible" width="520px"><div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;"><div style="color: var(--text-muted); font-size: 12px;">豸 project1/project2 log</div><el-button size="mini" icon="el-icon-refresh" @click="loadModelTree" :loading="modelTreeLoading" :disabled="!wsConnected"></el-button></div><el-tree v-if="modelTreeData && modelTreeData.length" :data="modelTreeData" node-key="label" :props="{ label: 'label', children: 'children' }" :default-expand-all="false" accordion></el-tree><div v-else style="color: var(--text-muted); font-size: 12px;">{{ wsConnected ? (modelTreeLoading ? '' : '') : 'WebSocket ' }}</div><span slot="footer" class="dialog-footer"><el-button size="mini" @click="dialogModelVisible = false"></el-button></span></el-dialog><el-dialog title="" :visible.sync="dialogLogVisible" width="560px"><div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;"><div style="color: var(--text-muted); font-size: 12px;">豸 log</div><el-button size="mini" icon="el-icon-refresh" @click="loadLogTree" :loading="logTreeLoading" :disabled="!wsConnected"></el-button></div><el-tree v-if="logTreeData && logTreeData.length" :data="logTreeData" node-key="label" :props="{ label: 'label', children: 'children' }" :default-expand-all="true" accordion @node-click="handleLogNodeClick"></el-tree><div v-else style="color: var(--text-muted); font-size: 12px;">{{ wsConnected ? (logTreeLoading ? '' : '/') : 'WebSocket ' }}</div><span slot="footer" class="dialog-footer"><el-button size="mini" @click="dialogLogVisible = false"></el-button><el-button size="mini" type="primary" @click="confirmPullLog" :disabled="!selectedLogPath"></el-button></span></el-dialog><el-dialog title="豸/" :visible.sync="dialogUpgradeVisible" width="980px"><div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;"><div style="color: var(--text-muted); font-size: 12px;">loader / SN / / 汾 get_connect_status 汾汾</div><el-button size="mini" type="primary" icon="el-icon-refresh" @click="checkCloudNewVersion" :loading="otaLoading" :disabled="!wsConnected">汾</el-button></div><div style="margin-bottom: 10px; font-size: 12px; color: var(--text-secondary);">{{ otaCloudStatusText }}</div><el-table :data="upgradeRows" size="mini" border style="width: 100%;"><el-table-column prop="ip" label="IP" width="140"></el-table-column><el-table-column prop="loader_name" label="Loader" width="140"></el-table-column><el-table-column prop="loader_num" label="" width="60"></el-table-column><el-table-column prop="sn" label="SN" width="140"></el-table-column><el-table-column prop="running_text" label="" width="90"></el-table-column><el-table-column prop="current_version" label="汾" width="140"></el-table-column><el-table-column label="汾" width="160"><template slot-scope="scope"><span v-if="scope.row.target_version">{{ scope.row.target_version }}</span> <span v-else style="color: var(--text-muted);">{{ otaCloudStatus === 'error' ? '' : (otaCloudStatus === 'empty' ? '汾' : (otaCloudStatus === 'never' ? '' : '')) }}</span></template></el-table-column><el-table-column label="" width="160"><template slot-scope="scope"><el-progress :percentage="Math.round(getOtaProgress(scope.row.ip, scope.row.loader_num))" :status="getOtaProgressStatus(scope.row.ip, scope.row.loader_num)" :stroke-width="10"></el-progress></template></el-table-column><el-table-column label="" min-width="220"><template slot-scope="scope"><el-button size="mini" type="success" @click="openLocalUpgrade(scope.row)" :disabled="!wsConnected"></el-button><el-button size="mini" type="primary" @click="startOta(scope.row.ip, scope.row.loader_num)" :disabled="!wsConnected"></el-button></template></el-table-column></el-table><span slot="footer" class="dialog-footer"><el-button size="mini" @click="dialogUpgradeVisible = false"></el-button></span></el-dialog><el-dialog title=" .hex " :visible.sync="dialogLocalUpgradeVisible" width="560px"><div style="margin-bottom: 15px; font-size: 12px; color: var(--text-muted);">豸{{ localUpgradeTarget.ip }} #{{ localUpgradeTarget.loader_num }}{{ localUpgradeTarget.loader_name || '' }}</div><el-tabs v-model="localUpgradeTab" type="border-card"><el-tab-pane label="" name="file"><div style="margin: 15px 0;"><el-upload action="#" :auto-upload="false" :limit="1" accept=".hex" :on-change="onHexSelected" :on-remove="onHexRemoved" :file-list="hexFileList"><el-button size="small" type="primary" icon="el-icon-folder-opened"></el-button><div slot="tip" class="el-upload__tip" style="margin-top: 8px; color: var(--text-muted); font-size: 12px;">.hex</div></el-upload><div v-if="selectedHexName" style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">{{ selectedHexName }}</div></div></el-tab-pane><el-tab-pane label="" name="path"><div style="margin: 15px 0;"><el-input v-model="localUpgradePath" placeholder=" .hex 磺D:\workspace\aaa.hex" size="small" style="width: 100%;"><template slot="prepend"></template></el-input><div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);"></div></div></el-tab-pane></el-tabs><span slot="footer" class="dialog-footer"><el-button size="mini" @click="dialogLocalUpgradeVisible = false" :disabled="localUpgradeLoading"></el-button><el-button size="mini" type="primary" :disabled="(!selectedHexName && !localUpgradePath) || localUpgradeLoading" :loading="localUpgradeLoading" @click="confirmLocalUpgrade"></el-button></span></el-dialog><el-drawer title="" :visible.sync="drawerConsoleVisible" direction="rtl" size="420px" :modal="false" :wrapper-closable="false" custom-class="non-modal-drawer"><div style="display:flex; flex-direction:column; height: 100%;"><div style="flex:1; overflow:auto; border:1px solid var(--border-color); border-radius:10px; padding:10px; background: var(--bg-white);"><div v-if="!consoleHistory.length" style="color: var(--text-muted); font-size: 12px;"></div><div v-for="(m, idx) in consoleHistory" :key="idx" style="margin-bottom:8px;"><div style="font-size:11px; color: var(--text-muted);">{{ m.ts }} {{ m.dir === 'out' ? '' : '' }}</div><pre style="white-space: pre-wrap; word-break: break-word; background: var(--bg-gray); padding:8px; border-radius:8px; font-family: var(--font-mono); font-size:12px; margin-top:4px;">{{ m.text }}</pre></div></div><div style="margin-top:10px; padding: 10px; background: var(--bg-gray); border: 2px solid var(--border-color); border-radius: 6px;"><div style="display:flex; gap:8px; align-items:center;"><el-input v-model="consoleInput" size="small" placeholder=" 120GET:CCV" style="flex: 1;" @keyup.enter.native="sendConsoleCmd"></el-input><el-button size="small" type="primary" @click="sendConsoleCmd" :disabled="!wsConnected || !consoleInput"></el-button></div></div><div style="margin-top:6px; font-size: 12px; color: var(--text-muted);">豸{{ device_id }} #{{ loader_num }}</div></div></el-drawer><el-dialog title=" Sheet" :visible.sync="dialogAddSheetVisible" width="400px"><el-form label-width="80px"><el-form-item label=""><el-input v-model="newSheetName" placeholder="磺" @keyup.enter.native="confirmAddSheet"></el-input></el-form-item></el-form><div slot="footer" class="dialog-footer"><el-button size="small" @click="dialogAddSheetVisible = false"></el-button><el-button size="small" type="primary" @click="confirmAddSheet"></el-button></div></el-dialog><div v-if="contextMenuVisible" class="context-menu" :style="{ left: contextMenuPos.x + 'px', top: contextMenuPos.y + 'px' }" @click.stop><div class="context-menu-item"><i class="el-icon-arrow-right"></i><div class="context-submenu"><div v-for="s in registerSheets.filter(x => x.id !== 'root')" :key="s.id" class="context-menu-item" @click="addRegToSheet(contextMenuReg, s.id)">{{ s.name }}</div><div v-if="registerSheets.length <= 1" class="context-menu-item muted"></div></div></div><div v-if="activeSheetId !== 'root'" class="context-menu-item danger" @click="removeRegFromCurrentSheet(contextMenuReg)"></div></div><div class="page-content" :class="{ active: activePage === 'info' }"><div class="page-header"><h2 class="page-title">豸</h2><el-button size="mini" icon="el-icon-refresh" @click="refreshDeviceInfo"></el-button></div><div class="page-body"><div class="device-overview-card"><div class="device-photo"><img src="img/device_info.png" alt="豸"><div class="device-photo-overlay" v-if="!deviceConnected"><i class="el-icon-warning"></i> <span>豸</span></div></div><div class="device-overview-info"><div class="device-overview-header"><h3 class="device-model-name">{{ currentDeviceName }}</h3><el-tag :type="deviceConnected ? 'success' : 'info'" size="small">{{ deviceConnected ? '' : '' }}</el-tag></div><div class="device-info-grid"><div class="info-item"><span class="info-label">豸</span> <span class="info-value sn">{{ deviceInfo.sn || '--' }}</span></div><div class="info-item"><span class="info-label">汾</span> <span class="info-value">{{ deviceInfo.hardwareVersion || '--' }}</span></div><div class="info-item"><span class="info-label">汾</span> <span class="info-value">{{ deviceInfo.softwareVersion || '--' }}</span></div><div class="info-item"><span class="info-label"></span> <span class="info-value highlight">{{ deviceInfo.runTime || '--' }}</span></div></div><div class="running-model-info" v-if="deviceConnected && isModelRunning"><div class="running-model-badge"><i class="el-icon-video-play"></i> <span></span></div><div class="running-model-detail"><span class="running-label">:</span> <span class="running-value">{{ runningFile }}</span> <span class="running-label">:</span> <span class="running-value">{{ getModuleDisplayName(runningModule) }}</span></div></div><div class="running-model-info stopped" v-else-if="deviceConnected"><div class="running-model-badge stopped"><i class="el-icon-video-pause"></i> <span></span></div></div></div></div><div class="spec-section"><h4 class="section-title"><i class="el-icon-data-analysis"></i> 豸</h4><div class="spec-grid"><div class="spec-card"><div class="spec-icon" style="background: rgba(37, 99, 235, 0.1); color: var(--primary-color);"><i class="el-icon-s-data"></i></div><div class="spec-content"><span class="spec-value">{{ currentSpecs.max_current_a }} A</span> <span class="spec-label"></span></div></div><div class="spec-card"><div class="spec-icon" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);"><i class="el-icon-lightning"></i></div><div class="spec-content"><span class="spec-value">{{ Math.abs(currentSpecs.max_voltage_v) }} V</span> <span class="spec-label"></span></div></div><div class="spec-card"><div class="spec-icon" style="background: rgba(245, 158, 11, 0.1); color: var(--warning-color);"><i class="el-icon-odometer"></i></div><div class="spec-content"><span class="spec-value">{{ currentSpecs.max_power_w }} W</span> <span class="spec-label"></span></div></div><div class="spec-card"><div class="spec-icon" style="background: rgba(139, 92, 246, 0.1); color: var(--running-color);"><i class="el-icon-time"></i></div><div class="spec-content"><span class="spec-value">{{ currentSpecs.sample_rate_khz }} kHz</span> <span class="spec-label"></span></div></div></div></div><div class="realtime-section" v-if="deviceConnected"><h4 class="section-title"><i class="el-icon-data-line"></i></h4><div class="realtime-grid"><div class="realtime-card"><span class="realtime-value">{{ realtimeData.current.toFixed(1) }}</span> <span class="realtime-unit">A</span> <span class="realtime-label"></span><div class="realtime-bar"><div class="realtime-bar-fill" :style="{ width: (realtimeData.current / 100 * 100) + '%' }"></div></div></div><div class="realtime-card"><span class="realtime-value">{{ realtimeData.voltage.toFixed(0) }}</span> <span class="realtime-unit">V</span> <span class="realtime-label"></span><div class="realtime-bar"><div class="realtime-bar-fill" :style="{ width: (realtimeData.voltage / 600 * 100) + '%', background: 'var(--success-color)' }"></div></div></div><div class="realtime-card"><span class="realtime-value">{{ realtimeData.power.toFixed(1) }}</span> <span class="realtime-unit">kW</span> <span class="realtime-label"></span><div class="realtime-bar"><div class="realtime-bar-fill" :style="{ width: (realtimeData.power / 50 * 100) + '%', background: 'var(--warning-color)' }"></div></div></div><div class="realtime-card"><span class="realtime-value">{{ realtimeData.temperature }}</span> <span class="realtime-unit">C</span> <span class="realtime-label"></span><div class="realtime-bar"><div class="realtime-bar-fill" :style="{ width: (realtimeData.temperature / 80 * 100) + '%', background: realtimeData.temperature > 60 ? 'var(--error-color)' : 'var(--running-color)' }"></div></div></div></div></div></div></div><div class="page-content" :class="{ active: activePage === 'model' }"><div class="page-header"><h2 class="page-title"></h2><div class="btn-group"><el-tooltip content="" placement="top"><button class="action-btn" :disabled="!wsConnected || !currentModel || !currentModel.path" @click="handleUploadCloud"><i class="el-icon-upload2"></i></button></el-tooltip><el-tooltip content="" placement="top"><button class="action-btn" :disabled="!wsConnected" @click="handleDownloadCloudModel"><i class="el-icon-download"></i></button></el-tooltip><span class="btn-divider"></span><el-tooltip content="豸洢" placement="top"><button class="action-btn" :disabled="!wsConnected" @click="handleLoadModelToDevice"><i class="el-icon-top"></i>豸</button></el-tooltip><el-tooltip content="豸" placement="top"><button class="action-btn" :disabled="!wsConnected" @click="handleGetFileInfo"><i class="el-icon-bottom"></i>豸</button></el-tooltip><span class="btn-divider"></span><el-tooltip content="浽" placement="top" :open-delay="500"><button class="action-btn primary" :disabled="!currentModel || !hasModified" @click="handleSave"><i class="el-icon-folder-checked"></i></button></el-tooltip><el-tooltip content="" placement="top" :open-delay="500"><button class="action-btn primary" :disabled="!currentModel || !currentModel.success" @click="handleSaveAs"><i class="el-icon-document-add"></i></button></el-tooltip><el-tooltip content="豸" placement="top" :open-delay="500"><button class="action-btn success" :disabled="!canApply" @click="handleApply"><i class="el-icon-video-play"></i></button></el-tooltip></div></div><div class="page-body"><div v-if="runMode === 'regen'" class="empty-state" style="height: 100%; padding: 60px 20px;"><i class="el-icon-info" style="font-size: 48px; color: var(--text-muted);"></i><p style="margin-top: 20px; color: var(--text-secondary);"></p><p style="margin-top: 10px; font-size: 12px; color: var(--text-muted);">""</p></div><template v-else><div class="data-path"><i class="el-icon-folder"></i> <span>: resource/loader/</span></div><div class="model-layout"><div class="model-list"><div class="model-list-header"><span></span><div style="display:flex; gap:5px; align-items:center;"><el-button type="text" size="mini" icon="el-icon-plus" @click="handleCreateNewModel" title=""></el-button></div></div><div v-for="(model, index) in models" :key="index" class="model-item" :class="{ 
                      active: activeModelIndex === index,
                      'has-error': model.errors && model.errors.length > 0,
                      'is-running': isFileRunning(model.filename)
                    }" @click="selectModel(index)"><i :class="model.success ? 'el-icon-document' : 'el-icon-document-delete'"></i><div class="model-item-info"><div class="model-item-name">{{ model.filename }}</div><div class="model-item-size">{{ model.modules ? model.modules.length + ' ' : '' }}</div></div><div class="model-item-btns" @click.stop><el-button type="text" size="mini" icon="el-icon-delete" class="delete-btn" @click="handleDeleteModel(model, index)" v-if="!isFileRunning(model.filename)" title=""></el-button></div><span v-if="isFileRunning(model.filename)" class="model-item-badge running"><i class="el-icon-video-play"></i></span></div></div><div class="model-editor" v-if="currentModel"><div class="editor-toolbar"><div class="editor-filename"><i class="el-icon-document"></i> <span>{{ currentModel.filename }}</span> <span class="modified-dot" v-if="hasModified"></span><el-tag v-if="isFileRunning(currentModel.filename)" size="mini" type="warning" effect="dark" style="margin-left:8px;"><i class="el-icon-video-play"></i></el-tag></div><div style="display:flex; gap:10px;"><el-button type="text" size="mini" icon="el-icon-circle-plus-outline" @click="handleOpenAddModuleDialog"></el-button><el-button type="text" size="mini" icon="el-icon-view" @click="showRaw = !showRaw">{{ showRaw ? '' : '' }}</el-button></div></div><div v-if="showRaw" style="flex: 1; overflow: auto;"><pre style="background: var(--bg-gray); padding: 12px; border-radius: 6px; font-family: var(--font-mono); font-size: 12px; line-height: 1.6; white-space: pre-wrap;">{{ currentModel.raw }}</pre></div><div v-else style="flex: 1; overflow-y: auto;"><div v-if="currentModel.modules && currentModel.modules.length"><div v-for="(mod, mi) in currentModel.modules" :key="mi" class="module-section" :class="{ 'is-running': isModuleRunning(currentModel.filename, mod.name) }"><div class="module-header" @click="toggleModule(mi)"><span class="module-toggle" :class="{ expanded: expandedModules[mi] }"><i class="el-icon-arrow-right"></i></span><div class="module-info"><div class="module-name-row"><span class="module-name">{{ mod.name }}</span> <span class="module-name-cn" v-if="getModuleDef(mod.name)">{{ getModuleDef(mod.name).name }}</span></div><div class="module-desc" v-if="getModuleDef(mod.name)">{{ getModuleDef(mod.name).description }}</div></div><span v-if="isModuleRunning(currentModel.filename, mod.name)" class="running-indicator"><i class="el-icon-video-play"></i> </span><span class="module-count">{{ mod.params.length }}</span><div class="module-btns" @click.stop><el-button type="text" size="mini" icon="el-icon-delete" class="delete-btn" @click="handleRemoveModule(mi)" v-if="!isModuleRunning(currentModel.filename, mod.name)" title=""></el-button></div></div><div class="module-body" :class="{ expanded: expandedModules[mi] }"><div v-if="expandedModules[mi]" style="padding: 8px; border-bottom: 1px solid var(--border-color); margin-bottom: 8px;"><el-button type="text" size="mini" icon="el-icon-plus" @click="handleOpenAddParamDialog(mi)" :disabled="isModuleRunning(currentModel.filename, mod.name)"></el-button></div><div v-for="(param, pi) in mod.params" :key="pi" class="param-row" :class="{ 'out-of-range': isOutOfRange(param) }"><div class="param-label-section"><div class="param-name-row"><span class="param-key">{{ param.name }}</span> <span class="param-name-cn" v-if="getParamDef(param.name)">{{ getParamDef(param.name).name }} </span><span class="param-unknown" v-else></span></div><div class="param-desc" v-if="getParamDef(param.name)">{{ getParamDef(param.name).description }}</div><div class="param-range" v-if="getParamDef(param.name) && getParamDef(param.name).min !== undefined"><i class="el-icon-info"></i> : {{ getParamDef(param.name).min }} ~ {{ getParamDef(param.name).max }} <span v-if="getParamDef(param.name).default !== undefined">(: {{ getParamDef(param.name).default }})</span></div></div><div class="param-input-section"><template v-if="param.type === 'single'"><div class="param-input-row"><el-input-number v-if="isNumericParam(param)" :value="param.value" size="mini" controls-position="right" :min="getParamDef(param.name) ? getParamDef(param.name).min : -Infinity" :max="getParamDef(param.name) ? getParamDef(param.name).max : Infinity" :step="getParamDef(param.name) ? (getParamDef(param.name).step || 1) : 1" :precision="getPrecision(param.name)" @change="updateSingleParam(param, $event)"></el-input-number><el-input v-else v-model="param.value" size="mini" @input="hasModified = true"></el-input><span class="param-unit">{{ getParamDef(param.name) ? getParamDef(param.name).unit : '' }}</span> <span class="param-type-badge">{{ param.type }}</span></div><div class="range-warning" v-if="isOutOfRange(param)"><i class="el-icon-warning"></i> 鷶</div></template><template v-else-if="param.type === 'array'"><div class="array-display"><div class="array-header"><span class="array-label">[{{ param.value.length }}]</span><el-button type="text" size="mini" icon="el-icon-plus" @click="addArrayItem(param)"></el-button></div><div class="array-items"><div v-for="(item, idx) in param.value" :key="idx" class="array-item"><span class="array-index">[{{ idx }}]</span><el-input-number v-if="typeof item === 'number'" :value="item" size="mini" controls-position="right" @change="updateArrayItem(param, idx, $event)"></el-input-number><el-input v-else :value="item" size="mini" @input="updateArrayItemStr(param, idx, $event)"></el-input><el-button type="text" size="mini" icon="el-icon-delete" @click="removeArrayItem(param, idx)"></el-button></div></div></div></template><template v-else-if="param.type === 'matrix'"><div class="matrix-display"><div class="matrix-toolbar"><span class="matrix-size">{{ param.value.length }} {{ param.value[0] ? param.value[0].length : 0 }}</span><el-button type="text" size="mini" icon="el-icon-plus" @click="addMatrixRow(param)"></el-button></div><div class="matrix-table"><div class="matrix-header" v-if="getParamDef(param.name) && getParamDef(param.name).columns"><span class="matrix-row-index">#</span> <span v-for="(col, ci) in getParamDef(param.name).columns" :key="ci" class="matrix-header-cell">{{ col }}</span> <span class="matrix-action-cell"></span></div><div v-for="(row, ri) in param.value" :key="ri" class="matrix-row"><span class="matrix-row-index">{{ ri }}</span><el-input-number v-for="(cell, ci) in row" :key="ci" :value="cell" size="mini" controls-position="right" class="matrix-cell-input" @change="updateMatrixCell(param, ri, ci, $event)"></el-input-number><el-button type="text" size="mini" icon="el-icon-delete" class="matrix-delete-btn" @click="removeMatrixRow(param, ri)"></el-button></div></div></div></template></div><div class="param-actions" style="margin-left: 10px;"><el-button type="text" size="mini" icon="el-icon-delete" @click="handleRemoveParam(mi, pi)" :disabled="isModuleRunning(currentModel.filename, mod.name)" title=""></el-button></div></div></div></div></div><div v-else class="empty-state"><i class="el-icon-warning-outline"></i><p></p></div></div></div><div v-else class="model-editor"><div class="empty-state" style="height: 100%;"><i class="el-icon-folder-opened"></i><p></p></div></div></div></template></div></div><el-dialog title="" :visible.sync="dialogNewModelVisible" width="400px"><el-form label-width="80px"><el-form-item label=""><el-input v-model="newModelFilename" placeholder=""><template slot="append">.bin</template></el-input></el-form-item></el-form><div slot="footer"><el-button size="mini" @click="dialogNewModelVisible = false"></el-button><el-button size="mini" type="primary" @click="confirmCreateNewModel"></el-button></div></el-dialog><el-dialog title="" :visible.sync="dialogAddModuleVisible" width="500px"><el-form label-width="100px"><el-form-item label=""><el-select v-model="selectedModuleType" placeholder="" style="width: 100%;" filterable><el-option v-for="mod in availableModules" :key="mod.id" :label="mod.name + ' (' + mod.id + ')'" :value="mod.id"><span style="float: left">{{ mod.name }}</span> <span style="float: right; color: #8492a6; font-size: 13px">{{ mod.id }}</span></el-option></el-select></el-form-item><div v-if="selectedModuleType" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;"><div style="font-weight: bold; margin-bottom: 5px;">:</div><div style="font-size: 13px; color: #606266;">{{ getModuleDesc(selectedModuleType) }}</div></div></el-form><div slot="footer"><el-button size="mini" @click="dialogAddModuleVisible = false"></el-button><el-button size="mini" type="primary" @click="confirmAddModule" :disabled="!selectedModuleType"></el-button></div></el-dialog><el-dialog title="" :visible.sync="dialogAddParamVisible" width="500px"><el-form label-width="100px"><el-form-item label=""><el-select v-model="selectedParamName" placeholder="" style="width: 100%;" filterable><el-option v-for="param in availableParamsForModule" :key="param.name" :label="param.displayName" :value="param.name"><span style="float: left">{{ param.displayName }}</span> <span style="float: right; color: #8492a6; font-size: 13px">ID: {{ param.id }}</span></el-option></el-select></el-form-item><div v-if="selectedParamName" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;"><div style="font-weight: bold; margin-bottom: 5px;">:</div><div style="font-size: 13px; color: #606266;">{{ getParamDef(selectedParamName) ? getParamDef(selectedParamName).description : '' }}</div></div></el-form><div slot="footer"><el-button size="mini" @click="dialogAddParamVisible = false"></el-button><el-button size="mini" type="primary" @click="confirmAddParam" :disabled="!selectedParamName"></el-button></div></el-dialog><el-dialog title="豸" :visible.sync="dialogImportDeviceVisible" width="400px"><el-form label-width="100px"><el-form-item label=""><el-radio-group v-model="importDeviceType"><el-radio label="current">豸</el-radio><el-radio label="all">豸</el-radio></el-radio-group></el-form-item><div v-if="currentModel" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;"><div style="font-size: 13px; color: #606266;"><div><strong>:</strong> {{ currentModel.filename }}</div><div><strong>:</strong> {{ currentModel.path }}</div></div></div></el-form><div slot="footer"><el-button size="mini" @click="dialogImportDeviceVisible = false"></el-button><el-button size="mini" type="primary" @click="confirmImportDevice"></el-button></div></el-dialog><div class="page-content" :class="{ active: activePage === 'register' }"><div class="page-header"><h2 class="page-title"></h2><div class="page-header-actions"><el-input v-model="registerSearch" placeholder="..." prefix-icon="el-icon-search" size="mini" style="width: 200px; margin-right: 10px;" clearable></el-input><el-button size="mini" icon="el-icon-refresh" @click="refreshSheetRegisters(currentSheet)" :loading="registerLoading"></el-button></div></div><div class="page-body register-page" style="display: flex; flex-direction: column;"><div style="display: flex; align-items: center; background: var(--bg-white); border-bottom: 1px solid var(--border-color); padding-left: 10px;"><el-tabs v-model="activeSheetId" type="card" @tab-remove="handleSheetRemove" style="margin-bottom: -1px;"><el-tab-pane v-for="(sheet, index) in registerSheets" :key="sheet.id" :name="sheet.id" :closable="sheet.id !== 'root'"><span slot="label" class="tab-label-zone" :class="{ 
                        'root-tab-label': sheet.id === 'root',
                        'drag-over-tab': dragOverTabIndex === index
                      }" :draggable="sheet.id !== 'root'" @dragstart="handleTabDragStart($event, index)" @dragover.prevent="handleTabDragOver($event, index)" @dragleave="handleTabDragLeave($event)" @drop="handleDropOnTab($event, index)"><i v-if="sheet.id === 'root'" class="el-icon-collection"></i> <span @dblclick="renameSheet(sheet)">{{ sheet.name }}</span> <i v-if="sheet.timerEnabled" class="el-icon-timer" style="color: var(--primary-color); margin-left: 4px;" title=""></i></span></el-tab-pane></el-tabs><el-button size="mini" type="text" icon="el-icon-plus" style="margin-left: 10px; padding: 8px;" @click="handleSheetAdd" title="5"></el-button></div><div v-if="activeSheetId !== 'root'" style="padding: 8px 12px; display: flex; align-items: center; gap: 15px; border-bottom: 1px solid var(--border-color); margin-bottom: 5px; background: #f8fafc;"><div style="font-size: 12px; color: var(--text-secondary); display: flex; align-items: center; gap: 5px;">:<el-switch v-model="currentSheet.timerEnabled" size="mini" @change="toggleSheetTimer(currentSheet)"></el-switch></div><div v-if="currentSheet.timerEnabled" style="font-size: 12px; color: var(--text-secondary); display: flex; align-items: center; gap: 5px;">:<el-input-number v-model="currentSheet.timerInterval" size="mini" :min="500" :max="20000" :step="1000" style="width: 100px;" @change="saveRegisterSheets(); startSheetTimer(currentSheet);"></el-input-number>ms</div><div style="flex: 1; text-align: right; font-size: 11px; color: var(--text-muted);"></div></div><div class="register-table-container" style="flex: 1; overflow: auto; margin-top: 5px;"><table class="register-table"><thead><tr><th width="80">ID</th><th width="150"></th><th width="100"><el-dropdown trigger="click" @command="v => registerTypeFilter = v"><span class="el-dropdown-link" style="cursor: pointer; font-size: 12px; color: inherit;"><i class="el-icon-arrow-down el-icon--right"></i></span><el-dropdown-menu slot="dropdown"><el-dropdown-item command="all" :disabled="registerTypeFilter === 'all'"></el-dropdown-item><el-dropdown-item command="int" :disabled="registerTypeFilter === 'int'"></el-dropdown-item><el-dropdown-item command="string" :disabled="registerTypeFilter === 'string'"></el-dropdown-item></el-dropdown-menu></el-dropdown></th><th width="100"><el-dropdown trigger="click" @command="v => registerFilter = v"><span class="el-dropdown-link" style="cursor: pointer; font-size: 12px; color: inherit;"><i class="el-icon-arrow-down el-icon--right"></i></span><el-dropdown-menu slot="dropdown"><el-dropdown-item command="all" :disabled="registerFilter === 'all'"></el-dropdown-item><el-dropdown-item command="read" :disabled="registerFilter === 'read'"></el-dropdown-item><el-dropdown-item command="write" :disabled="registerFilter === 'write'"></el-dropdown-item><el-dropdown-item command="readwrite" :disabled="registerFilter === 'readwrite'"></el-dropdown-item></el-dropdown-menu></el-dropdown></th><th width="150"></th><th></th><th></th><th width="160"></th></tr></thead><tbody><tr v-for="(reg, index) in filteredRegisters" :key="reg.name" draggable="true" @dragstart="handleDragStart($event, reg, index)" @dragover.prevent="handleDragOverRow($event, index)" @dragleave="handleDragLeaveRow($event)" @drop="handleDropOnRow($event, index)" @contextmenu.prevent="showContextMenu($event, reg)" :class="{ 
                        'reg-modified': reg.modified, 
                        'reg-read-error': reg.readError,
                        'drag-over-row': dragOverRowIndex === index 
                      }"><td class="reg-id">0x{{ reg.address.toString(16).toUpperCase().padStart(4, '0') }}</td><td class="reg-name">{{ reg.name }}</td><td><el-tag size="mini" :type="reg.type === 'int' ? '' : 'warning'">{{ reg.type === 'int' ? '' : '' }}</el-tag></td><td><el-tag size="mini" :type="reg.access === 'read' ? 'info' : (reg.access === 'write' ? 'danger' : 'success')">{{ reg.access === 'read' ? '' : (reg.access === 'write' ? '' : '') }}</el-tag></td><td class="reg-value" :class="{ 'text-danger': reg.readError }"><template v-if="reg.access !== 'write'">{{ reg.readError ? '' : (reg.value !== null ? reg.value : '--') }}</template><span v-else class="muted">--</span></td><td class="reg-write"><div v-if="reg.access !== 'read'" class="reg-input-wrap"><input v-if="reg.type === 'int'" type="number" class="reg-input" v-model.number="reg.inputValue" @keyup.enter="writeRegister(reg)" :placeholder="reg.access === 'write' ? '' : ''" :min="reg.min !== null ? reg.min : undefined" :max="reg.max !== null ? reg.max : undefined"> <input v-else type="text" class="reg-input" v-model="reg.inputValue" @keyup.enter="writeRegister(reg)" :placeholder="reg.access === 'write' ? '' : ''"></div><span v-else class="muted"></span></td><td class="reg-desc"><div>{{ reg.description }}</div><div v-if="reg.type === 'int' && reg.min !== null && reg.max !== null" class="reg-range">: {{ reg.min }} ~ {{ reg.max }}</div></td><td class="reg-actions"><el-button v-if="reg.access !== 'write'" size="mini" icon="el-icon-refresh" :loading="reg.loading" @click="readRegister(reg)"></el-button><el-button v-if="reg.access !== 'read'" size="mini" type="primary" icon="el-icon-upload2" :disabled="reg.inputValue === '' || reg.inputValue === null" @click="writeRegister(reg)"></el-button></td></tr></tbody></table><div v-if="filteredRegisters.length === 0" class="empty-state" style="padding: 40px;"><i class="el-icon-folder-opened"></i><p></p></div></div><div class="register-stats"><span>{{ registers.length }} </span><span>|</span> <span>: {{ registers.filter(r => r.access === 'read').length }}</span> <span>: {{ registers.filter(r => r.access === 'write').length }}</span> <span>: {{ registers.filter(r => r.access === 'readwrite').length }}</span></div></div></div></div></div></div></div><script>//  /api/model/dictionary  WS action: model.dictionary
    let modelDictionary = { parameters: {}, modules: {} };

    // ============================================================
    // WebSocket 
    // ============================================================
    class WSClient {
      constructor(url = null) {
        // 
        // - WebSocket  Python  28657
        // -  window.WS_URL  /ws 
        if (!url) {
          if (window.WS_URL) {
            url = window.WS_URL;
          } else {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const host = window.location.hostname;
          // Python WS 
          url = protocol + '//' + host + ':28657/ws';
          }
        }
        this.url = url;
        this.ws = null;
        this.connected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectInterval = 3000;
        // Python WS cmd_id/topic  sim_loader
        //  topic  LOADER
        this.topic = 'LOADER';
        this.messageId = 0; //  cmd_id
        this.pendingRequests = new Map();
        this.listeners = new Map();
        this.requestTimeout = 10000;
      }

      /**
       * WebSocket
       */
      connect() {
        return new Promise((resolve, reject) => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            resolve();
            return;
          }

          this.ws = new WebSocket(this.url);

          this.ws.onopen = () => {
            console.log('[WS] ');
            this.connected = true;
            this.reconnectAttempts = 0;
            //  UI 
            try {
              // 
              this.ws.send('Hello, I am loader');
            } catch (e) {
              console.warn('[WS] hello handshake failed:', e);
            }
            //  hello  connected
            //  connected  device.info  hello
            this.emit('connected');
            resolve();
          };

          this.ws.onclose = (event) => {
            console.log('[WS] ', event.code, event.reason);
            this.connected = false;
            this.emit('disconnected');
            this.tryReconnect();
          };

          this.ws.onerror = (error) => {
            console.error('[WS] ', error);
            this.emit('error', error);
            reject(error);
          };

          this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
          };
        });
      }

      /**
       * 
       */
      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        this.connected = false;
      }

      /**
       * 
       */
      tryReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
          console.log('[WS] ');
          this.emit('reconnectFailed');
          return;
        }

        this.reconnectAttempts++;
        console.log('[WS]  (' + this.reconnectAttempts + '/' + this.maxReconnectAttempts + ')...');
        
        setTimeout(() => {
          this.connect().catch(() => {});
        }, this.reconnectInterval);
      }

      /**
       * 
       */
      handleMessage(data) {
        try {
          if (typeof data !== 'string') return;
          const message = JSON.parse(data);

          //  socket.md 
          if (Array.isArray(message)) {
            if (this.pendingRequests.size > 0) {
              //  cmd_id
              let latestKey = null;
              for (const k of this.pendingRequests.keys()) {
                if (latestKey === null || Number(k) > Number(latestKey)) latestKey = k;
              }
              const pending = latestKey !== null ? this.pendingRequests.get(latestKey) : null;
              if (pending) {
                const { resolve, timer } = pending;
                clearTimeout(timer);
                this.pendingRequests.delete(latestKey);
                resolve({ topic: this.topic, cmd_id: latestKey, name: 'anonymous.array', data: message });
                return;
              }
            }
            this.emit('anonymous.array', message);
            return;
          }
          
          // 
          // cmd_id 
          const rawCmdId = message.cmd_id !== undefined ? message.cmd_id : message.id;
          const cmdId = (rawCmdId !== undefined && rawCmdId !== null) ? String(rawCmdId) : null;

          if (cmdId && this.pendingRequests.has(cmdId)) {
            const { resolve, reject, timer } = this.pendingRequests.get(cmdId);
            clearTimeout(timer);
            this.pendingRequests.delete(cmdId);
            
            //  socket.md { topic, cmd_id, name, data: {...} } 
            // data  JSON 
            let responseData = message;
            if (message.data !== undefined) {
              if (typeof message.data === 'string') {
                try { 
                  const parsed = JSON.parse(message.data);
                  // 飨 get_signals
                  responseData = parsed;
                } catch (e) { 
                  responseData = message.data; 
                }
              } else {
                //  data 飨 get_signals
                responseData = message.data;
              }
            }
            
            // success=false / ok=false / code!=0
            const ok = (responseData.success !== false) && (responseData.ok !== false) && (responseData.code === undefined || responseData.code === 0);
            if (!ok && responseData.success === false) {
              reject(new Error(responseData.error || responseData.msg || responseData.desc || ''));
            } else {
              resolve(responseData);
            }
            return;
          }

          // /
          if (message && message.name) {
            // data  socket.md  JSON
            let processedData = message.data;
            if (typeof message.data === 'string' && (message.data.startsWith('{') || message.data.startsWith('['))) {
              try { processedData = JSON.parse(message.data); } catch (e) {}
            }
            //  refresh_signals 31
            if (message.name === 'refresh_signals') {
              // refresh_signals  data 
              this.emit('refresh_signals', processedData);
            } else {
              this.emit(message.name, processedData);
            }
          }
          if (message && message.type) {
            this.emit(message.type, message.data);
          }
        } catch (err) {
          console.error('[WS] :', err, ':', data);
        }
      }

      /**
       * 
       * @param {string} action - 
       * @param {object} params - 
       * @returns {Promise<object>} - 
       */
      request(action, params = {}) {
        return new Promise((resolve, reject) => {
          if (!this.connected) {
            reject(new Error('WebSocket '));
            return;
          }

          // =====  Python WS  =====
          // dict = { topic:'sim_loader', cmd_id:, name:, data: }
          //  window.WS_METHOD_MAP action -> name
          const cmd_id = Date.now() * 1000 + ((++this.messageId) % 1000);
          const cmdIdStr = String(cmd_id);
          const map = window.WS_METHOD_MAP || {};
          const name = map[action] || action;
          // data  JSON  "{}" / "{\"device_id\":\"127.0.0.1\"}"
          //  string  data
          const dataField = (typeof params === 'string') ? params : JSON.stringify(params || {});
          const message = { topic: this.topic, cmd_id, name, data: dataField };

          // 
          const timer = setTimeout(() => {
            this.pendingRequests.delete(cmdIdStr);
            reject(new Error(''));
          }, this.requestTimeout);

          this.pendingRequests.set(cmdIdStr, { resolve, reject, timer });

          console.log('[WS] :', name, params, 'cmd_id=', cmd_id);
          this.ws.send(JSON.stringify(message));
        });
      }

      /**
       * 
       */
      send(action, params = {}) {
        if (!this.connected) {
          console.warn('[WS] ');
          return false;
        }
        const cmd_id = Date.now() * 1000 + ((++this.messageId) % 1000);
        const map = window.WS_METHOD_MAP || {};
        const name = map[action] || action;
        const dataField = (typeof params === 'string') ? params : JSON.stringify(params || {});
        this.ws.send(JSON.stringify({ topic: this.topic, cmd_id, name, data: dataField }));
        return true;
      }

      /**
       * 
       */
      on(event, callback) {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
      }

      /**
       * 
       */
      off(event, callback) {
        if (this.listeners.has(event)) {
          const list = this.listeners.get(event);
          const idx = list.indexOf(callback);
          if (idx !== -1) list.splice(idx, 1);
        }
      }

      /**
       * 
       */
      emit(event, data) {
        if (this.listeners.has(event)) {
          this.listeners.get(event).forEach(cb => cb(data));
        }
      }

      // ============================================================
      // API 
      // ============================================================

      // ============================================================
      // socket.md(1~13)  topic=LOADERdata  JSON 
      // ============================================================

      // --- loader 5s name=get_connect_status---
      startGetConnectStatus() {
        return this.request('start_get_connect_status', {});
      }

      // ---  ---
      stopAllTimers() {
        return this.request('stop_all_timers', {});
      }

      // --- loader  ---
      queryLocationInfo() {
        return this.request('query_location_info', {});
      }

      // --- ---
      getModels(device_id, loader_num, sim_type = 'component_emulation') {
        return this.request('get_models', { device_id, loader_num, sim_type });
      }

      // ---  ---
      startLoader(device_id, loader_num, model, sim_type = 'component_emulation') {
        // model: ["project1","Window_Left"]
        return this.request('start_loader', { device_id, loader_num, model, sim_type });
      }

      // ---  ---
      stopLoader(device_id, loader_num, model, sim_type = 'component_emulation') {
        // model: ["project1","Window"]
        return this.request('stop_loader', { device_id, loader_num, model, sim_type });
      }

      // --- 6 get_signals---
      getSignals(device_id, loader_num, regs) {
        // regs 
        const regsArray = Array.isArray(regs) ? regs : (regs ? [regs] : []);
        return this.request('get_signals', { device_id, loader_num, regs: regsArray });
      }

      // --- 31 schedule_refresh_signals---
      scheduleRefreshSignals(device_id, loader_num, regs, period) {
        // regs 
        const regsArray = Array.isArray(regs) ? regs : (regs ? [regs] : []);
        return this.request('schedule_refresh_signals', { device_id, loader_num, regs: regsArray, period });
      }

      // --- 32 stop_refresh_regs---
      stopRefreshRegs() {
        return this.request('stop_refresh_regs', {});
      }

      // --- 8 set_signals---
      setSignals(device_id, loader_num, signals) {
        return this.request('set_signals', { device_id, loader_num, signals });
      }

      // --- 9  loader get_file_info---
      getFileInfo(device_id, loader_num, name = '') {
        return this.request('get_file_info', { device_id, loader_num, name });
      }

      // --- 10  resource/loader obtain_loader_dir_structure---
      obtainLoaderDirStructure(path = 'loader') {
        return this.request('obtain_loader_dir_structure', { path });
      }

      // --- 11 load_model---
      loadModel(device_id, loader_num, modelzip, project, all_devices = false) {
        if (all_devices) {
          return this.request('load_model', { modelzip, project, all_devices: true });
        } else {
          return this.request('load_model', { device_id, loader_num, modelzip, project, all_devices: false });
        }
      }

      // --- 12 download_cloud_models---
      downloadCloudModels(device_id, loader_num, model_name, model_id, project) {
        return this.request('download_cloud_models', { device_id, loader_num, model_name, model_id, project });
      }

      // --- 13 send_cmd---
      sendCmd(device_id, loader_num, cmd, multi_frames = false) {
        return this.request('send_cmd', { device_id, loader_num, cmd, multi_frames });
      }

      // --- 14 汾check_loaders_new_version---
      checkLoadersNewVersion() {
        return this.request('check_loaders_new_version', {});
      }

      // --- 15 豸 OTAupdate_one_loader---
      updateOneLoader(device_id, loader_num) {
        return this.request('update_one_loader', { device_id, loader_num });
      }

      // --- 17 set_reg_value---
      setRegValue(device_id, loader_num, reg_name, reg_value) {
        return this.request('set_reg_value', { device_id, loader_num, reg_name, reg_value: String(reg_value) });
      }

      // --- 18 wait_reg_value---
      waitRegValue(device_id, loader_num, reg_name) {
        return this.request('wait_reg_value', { device_id, loader_num, reg_name });
      }

      // --- 19 save_location_info ---
      saveLocationInfo(location) {
        return this.request('save_location_info', { location });
      }

      // --- 20 get_local_file_list ---
      getLocalFileList() {
        return this.request('get_local_file_list', {});
      }

      // --- 21 read_local_file ---
      readLocalFile(path) {
        return this.request('read_local_file', { path });
      }

      // --- 22 save_local_file ---
      saveLocalFile(path, content) {
        return this.request('save_local_file', { path, content });
      }

      // --- 23 save_as_local_file ---
      saveAsLocalFile(path, content) {
        return this.request('save_as_local_file', { path, content });
      }

      // --- 24 upload_to_cloud ---
      uploadToCloud(path) {
        return this.request('upload_to_cloud', { path });
      }

      // --- 25 豸download_from_device ---
      downloadFromDevice(device_id, loader_num, device_path, local_path) {
        return this.request('download_from_device', { device_id, loader_num, device_path, local_path });
      }

      // --- 26 豸apply_params_to_device ---
      applyParamsToDevice(device_id, loader_num, path, content) {
        return this.request('apply_params_to_device', { device_id, loader_num, path, content });
      }

      // --- 27 stop_all_timers ---
      stopAllTimers() {
        return this.request('stop_all_timers', {});
      }

      // --- 28 delete_local_file ---
      deleteLocalFile(path) {
        return this.request('delete_local_file', { path });
      }

      // --- 29 OTAloader_ota ---
      loaderOta(device_id, loader_num, path) {
        return this.request('loader_ota', { device_id, loader_num, path });
      }

      // --- 30 pull_file ---
      pullFile(device_id, loader_num, path) {
        return this.request('pull_file', { device_id, loader_num, path });
      }

      // ---  socket.md  Python FastAPI  ---
      saveFile(device_sn, filename, content) {
        return this.request('file.save', { device_sn, filename, content });
      }
      saveFileAs(device_sn, filename, content) {
        return this.request('file.saveAs', { device_sn, filename, content });
      }
      readFile(device_sn, filename) {
        return this.request('file.read', { device_sn, filename });
      }
      deleteFile(device_sn, filename) {
        return this.request('file.delete', { device_sn, filename });
      }
      listFiles(device_sn) {
        return this.request('file.list', { device_sn });
      }
    }

    //  WebSocket 
    const wsClient = new WSClient();

    // bin  socket.md  WSname=bin_parse
    async function parseBinByServer(filePath) {
      // WS HTTP 
      if (wsClient && wsClient.connected) {
        const msg = await wsClient.request('bin_parse', { path: filePath });
        const dataField = msg && msg.data !== undefined ? msg.data : msg;
        let parsed = dataField;
        if (typeof dataField === 'string') {
          try { parsed = JSON.parse(dataField); } catch (e) {}
        }
        // 
        // 1) {success:true,...}
        // 2) {ret:true,data:{success:true,...},desc:""}socket.md 
        let result = null;
        if (parsed && parsed.success !== undefined) result = parsed;
        else if (parsed && parsed.ret === true && parsed.data) result = parsed.data;
        else result = parsed;

        //  content raw  UI 鿴
        if (result && parsed && parsed.content) {
          result.raw = parsed.content;
        }
        return result;
      }
      const resp = await fetch('/api/bin/parse', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: filePath })
      });
      return await resp.json();
    }

    // 
    const sampleFiles = {
      'example.bin': `#
#
WINDOW_R
up_limit:2200
down_limit:0
vout_gain:1.5
current_output_gain:0.5
stuck_mode:2000
matrix1:3 4 5

#
TAIL_GATE_LOCK
signal_tailgate_1:1
signal_tailgate_2:1
vout_gain:1.2
current_output_gain:0.3
example_factor:
    0 0 0
    1 2.3 4.51
    2 3.4 6.66`,

      'motor_control.bin': `#
MOTOR_CTRL
max_speed:3000
min_speed:0
acceleration:100
deceleration:150
pid_kp:1.5
pid_ki:0.2
pid_kd:0.05

BRAKE_CTRL
brake_force:80
release_delay:50`,

      'test_out_of_range.bin': `#
WINDOW_R
up_limit:99999
vout_gain:15.5
current_output_gain:0.5`
    };

    new Vue({
      el: '#app',
      data: {
        wsConnected: false,        // WebSocket
        // / get_connect_status 
        deviceConnected: false,
        deviceSN: '',
        //  start_loader/stop_loader/get_models 
        device_id: '127.0.0.1',
        loader_num: 0,

        // //豸
        locationList: [],
        selectedLocation: '',
        isLocationRegistered: false,
        connectStatus: null, // get_connect_status  data
        selectedDeviceKey: '', // ip + '#' + loader_num
        lastConnectStatusTime: 0, //  get_connect_status 
        connectStatusCheckTimer: null, // get_connect_status 鶨
        hasRequestedConnectStatus: false, // 

        // 豸棨 MFILE 豸
        deviceSignalCache: {}, // key -> { MFILE, ... }

        // OTAsocket.md 14/15
        otaLoading: false,
        otaGroups: [],
        otaProgress: {}, // key: ip + '#' + loader_num -> number(0-100)
        otaStatus: {},   // key -> { status, desc }
        otaUpdatingKey: '',
        otaCloudStatus: 'never', // never | ok | empty | error
        otaCloudMsg: '',
        otaCloudCheckedAt: '',

        // 
        dialogModelVisible: false,
        dialogUpgradeVisible: false,
        dialogLogVisible: false,
        dialogLocalUpgradeVisible: false,
        drawerConsoleVisible: false,

        // hex 
        localUpgradeTarget: { ip: '', loader_num: 0, loader_name: '' },
        selectedHexFile: null,
        selectedHexName: '',
        selectedHexPath: '', // 
        hexFileList: [],
        localUpgradeLoading: false, // 
        localUpgradeTab: 'file', // 'file'  'path'
        localUpgradePath: '', // 

        // 
        consoleInput: '',
        consoleHistory: [],

        // 豸/
        modelTreeLoading: false,
        modelTreeData: [],
        logTreeLoading: false,
        logTreeData: [],
        selectedLogPath: '', // 

        // 豸 device_specs.json 
        deviceSpecsConfig: null,
        //  NAME 豸
        deviceNameFromRegister: '',

        // 
        modelOptionsLoading: false,
        modelOptions: [],
        selectedModelPath: [],
        runMode: 'model', // model | regen ()
        activeTool: 'model',
        activePage: 'info',
        activeModelIndex: 0,
        hasModified: false,
        showRaw: false,
        expandedModules: {},
        models: [],
        isModelRunning: false,
        runningFile: '',
        runningModule: 'WINDOW_R',
        // 豸
        deviceInfo: {
          sn: '',
          hardwareVersion: '',
          softwareVersion: '',
          runTime: ''
        },
        // 
        realtimeData: {
          current: 0,
          voltage: 0,
          power: 0,
          temperature: 0
        },
        // 
        registerSearch: '',
        registerFilter: 'all',
        registerTypeFilter: 'all',
        registerLoading: false,
        registers: [],
        registerDefsAll: [],
        
        // Sheet
        activeSheetId: 'root',
        registerSheets: [
          { id: 'root', name: '', registerNames: [], timerEnabled: false, timerInterval: 5000, timerId: null }
        ],
        dialogAddSheetVisible: false,
        newSheetName: '',
        dragOverRowIndex: null,
        dragOverTabIndex: null,
        draggedRegName: '',
        
        // 
        contextMenuVisible: false,
        contextMenuPos: { x: 0, y: 0 },
        contextMenuReg: null,
        
        // /鶨壩
        modelDictionary: { parameters: {}, modules: {} },
        
        // /鵯
        dialogNewModelVisible: false,
        newModelFilename: '',
        dialogAddModuleVisible: false,
        selectedModuleType: '',
        // 
        dialogAddParamVisible: false,
        selectedParamName: '',
        selectedModuleIndexForParam: -1, // 
        // 豸
        dialogImportDeviceVisible: false,
        importDeviceType: 'current' // 'current' | 'all'
      },
      watch: {
        // 
        async activeSheetId(newId, oldId) {
          if (oldId && oldId !== newId && this.wsConnected) {
            // 
            try {
              await wsClient.stopRefreshRegs();
              console.log('[Sheet] ');
            } catch (err) {
              console.error('[Sheet] :', err);
            }
            
            // 
            const oldSheet = this.registerSheets.find(s => s.id === oldId);
            if (oldSheet && oldSheet.timerEnabled) {
              oldSheet.timerId = null;
              oldSheet.timerEnabled = false;
            }
          }
        }
      },
      computed: {
        currentSheet() {
          return this.registerSheets.find(s => s.id === this.activeSheetId) || this.registerSheets[0];
        },
        filteredRegisters() {
          const sheet = this.currentSheet;
          let list = [];
          if (sheet.id === 'root') {
            list = this.registers;
          } else {
            //  sheet.registerNames 
            const names = sheet.registerNames || [];
            list = names.map(name => this.registers.find(r => r.name === name)).filter(Boolean);
          }

          return list.filter(reg => {
            // 
            if (this.registerSearch) {
              const search = this.registerSearch.toLowerCase();
              const nameMatch = reg.name.toLowerCase().includes(search);
              const descMatch = reg.description.toLowerCase().includes(search);
              if (!nameMatch && !descMatch) return false;
            }
            // 
            if (this.registerFilter !== 'all' && reg.access !== this.registerFilter) return false;
            // 
            if (this.registerTypeFilter !== 'all' && reg.type !== this.registerTypeFilter) return false;
            return true;
          });
        },
        currentDeviceEntry() {
          //  connectStatus  device_id + loader_num 豸
          // : { lab: [ { ip, port, value: [device,...] }, ... ] }
          // : { lab: [ device, ... ] }
          const raw = this.connectStatus && typeof this.connectStatus === 'object' ? this.connectStatus : {};
          for (const items of Object.values(raw)) {
            if (!Array.isArray(items)) continue;
            for (const item of items) {
              if (!item) continue;
              //  cabinet  device 
              if (Array.isArray(item.value)) {
                // 
                for (const d of item.value) {
                  if (d && String(d.ip) === String(this.device_id) && Number(d.loader_num) === Number(this.loader_num)) {
                    return d;
                  }
                }
              } else {
                // 
                if (String(item.ip) === String(this.device_id) && Number(item.loader_num) === Number(this.loader_num)) {
                  return item;
                }
              }
            }
          }
          return null;
        },
        currentDeviceName() {
          // 豸connect_status.name ->  NAME -> 
          const entry = this.currentDeviceEntry;
          const n1 = entry && entry.name ? String(entry.name).trim() : '';
          if (n1) return n1;
          const n2 = (this.deviceNameFromRegister || '').trim();
          if (n2) return n2;
          return 'X-Loader';
        },
        currentHardwareVersion() {
          // 汾connect_status.hversion -> deviceInfo.hardwareVersion -> default
          const entry = this.currentDeviceEntry;
          const v1 = entry && entry.hversion ? String(entry.hversion).trim() : '';
          if (v1) return v1;
          const v2 = this.deviceInfo && this.deviceInfo.hardwareVersion ? String(this.deviceInfo.hardwareVersion).trim() : '';
          if (v2) return v2;
          return 'default';
        },
        currentSpecs() {
          //  豸 + 汾  deviceSpecsConfig  default/default
          const cfg = this.deviceSpecsConfig || {};
          const nameMap = cfg[this.currentDeviceName] || cfg['default'] || {};
          const spec = nameMap[this.currentHardwareVersion] || nameMap['default'] || (cfg.default && cfg.default.default) || {
            max_current_a: 100,
            max_voltage_v: 600,
            max_power_w: 50000,
            sample_rate_khz: 100
          };
          return spec;
        },
        currentModel() { return this.models[this.activeModelIndex] || null; },
        canApply() {
          return this.deviceConnected && this.isModelRunning && 
                 this.currentModel && this.currentModel.success &&
                 this.isFileRunning(this.currentModel.filename);
        },
        canStartSelected() {
          return Array.isArray(this.selectedModelPath) && this.selectedModelPath.length >= 2;
        },
        canStopSelected() {
          // 
          return this.deviceConnected && this.isModelRunning;
        },
        hasConnectStatus() {
          return this.connectStatus && typeof this.connectStatus === 'object' && Object.keys(this.connectStatus).length > 0;
        },
        availableModules() {
          if (!this.modelDictionary || !this.modelDictionary.modules) return [];
          return Object.entries(this.modelDictionary.modules).map(([id, def]) => ({
            id,
            name: def.name || id
          }));
        },
        availableParamsForModule() {
          // 
          if (this.selectedModuleIndexForParam < 0 || !this.currentModel || !this.currentModel.modules) return [];
          
          const module = this.currentModel.modules[this.selectedModuleIndexForParam];
          if (!module || !this.modelDictionary || !this.modelDictionary.modules) return [];
          
          const modDef = this.modelDictionary.modules[module.name];
          if (!modDef) return [];
          
          // ID
          const allowedIds = modDef.allowed_param_ids || [];
          
          // 
          const existingParamNames = new Set(module.params.map(p => p.name));
          
          // 
          const params = [];
          if (this.modelDictionary.parameters) {
            Object.entries(this.modelDictionary.parameters).forEach(([name, def]) => {
              // ID
              if (def.id && allowedIds.includes(def.id)) {
                // 
                if (!existingParamNames.has(name)) {
                  params.push({
                    name,
                    id: def.id,
                    displayName: (def.name || name) + ' (' + name + ')'
                  });
                }
              }
            });
          }
          
          // ID
          params.sort((a, b) => a.id - b.id);
          
          return params;
        },
        currentSimType() {
          return this.runMode === 'regen' ? 'data_replay' : 'component_emulation';
        },
        otaCloudMap() {
          //  check_loaders_new_version key -> { target_version, current_version, sn, loader_name, progress }
          const map = {};
          for (const grp of (this.otaGroups || [])) {
            const ip = grp && grp.ip ? String(grp.ip) : '';
            for (const d of (grp.devices || [])) {
              const k = this.otaKey(ip, d.loader_num);
              map[k] = {
                target_version: d.target_version || '',
                current_version: d.current_version || '',
                sn: d.sn || '',
                loader_name: d.loader_name || '',
                progress: d.progress
              };
            }
          }
          return map;
        },
        otaCloudStatusText() {
          if (this.otaCloudStatus === 'never') return '汾';
          if (this.otaCloudStatus === 'ok') return '汾' + (this.otaCloudCheckedAt || '') + '';
          if (this.otaCloudStatus === 'empty') return '汾汾' + (this.otaCloudCheckedAt || '') + '';
          if (this.otaCloudStatus === 'error') return '汾' + (this.otaCloudMsg || '') + '';
          return '汾';
        },
        upgradeRows() {
          //  upgrade  get_connect_status 汾 otaCloudMap
          const rows = [];
          const raw = this.connectStatus && typeof this.connectStatus === 'object' ? this.connectStatus : {};
          
          const processDevice = (d) => {
            if (!d || d.ip === undefined || d.loader_num === undefined) return;
            const ip = String(d.ip);
            const loader_num = Number(d.loader_num);
            const k = this.otaKey(ip, loader_num);
            const cloud = this.otaCloudMap[k] || {};
            rows.push({
              ip,
              loader_num,
              loader_name: d.loader_name || cloud.loader_name || ('loader-' + loader_num),
              sn: d.sn || cloud.sn || '',
              running_text: (this.toBool(d.running) ? '' : ''),
              current_version: d.version || cloud.current_version || '',
              target_version: cloud.target_version || ''
            });
          };

          for (const items of Object.values(raw)) {
            if (!Array.isArray(items)) continue;
            for (const item of items) {
              if (!item) continue;
              if (Array.isArray(item.value)) {
                item.value.forEach(processDevice);
              } else {
                processDevice(item);
              }
            }
          }
          // IP -> loader_num
          rows.sort((a, b) => (a.ip === b.ip ? a.loader_num - b.loader_num : a.ip.localeCompare(b.ip)));
          return rows;
        },
        labView() {
          // connectStatus : { "lab-1": [ { ip, port, value: [device,...] }, ... ] }
          // connectStatus : { "lab-1": [ device, ... ] }
          const raw = this.connectStatus && typeof this.connectStatus === 'object' ? this.connectStatus : {};
          const labs = [];
          for (const [labKey, items] of Object.entries(raw)) {
            const list = Array.isArray(items) ? items : [];
            const cabinets = [];

            // /
            for (const item of list) {
              if (!item) continue;
              
              let ip = 'unknown';
              let devicesRaw = [];

              if (Array.isArray(item.value)) {
                // 
                ip = item.ip || 'unknown';
                devicesRaw = item.value;
              } else {
                //  IP 鵽
                ip = item.ip || 'unknown';
                //  IP 
                let cab = cabinets.find(c => c.ip === ip);
                if (!cab) {
                  cab = { ip, devices: this.createEmptySlots(ip) };
                  cabinets.push(cab);
                }
                this.fillSlot(cab.devices, item, ip);
                continue; 
              }

              // 
              const slots = this.createEmptySlots(ip);
              for (const d of devicesRaw) {
                this.fillSlot(slots, d, ip);
              }
              cabinets.push({ ip, devices: slots });
            }
            labs.push({ labKey, cabinets });
          }
          return labs;
        }
      },
      methods: {
        //  6  labView 
        createEmptySlots(ip) {
          return new Array(6).fill(null).map((_, idx) => ({
            ip,
            loader_num: idx,
            connect: false,
            running: false,
            interrupt: false,
            high_temp_alarm: false,
            busy: false,
            running_model: ''
          }));
        },
        //  labView 
        fillSlot(slots, d, ip) {
          const n = Number(d.loader_num);
          if (Number.isFinite(n) && n >= 0 && n < 6) {
            const cacheKey = String(ip) + '#' + n;
            const cached = this.deviceSignalCache && this.deviceSignalCache[cacheKey] ? this.deviceSignalCache[cacheKey] : null;
            slots[n] = {
              ...slots[n],
              ...d,
              loader_num: n,
              connect: this.toBool(d.connect),
              running: this.toBool(d.running),
              interrupt: this.toBool(d.interrupt),
              high_temp_alarm: this.toBool(d.high_temp_alarm),
              busy: this.toBool(d.busy),
              //  MFILE >  loader_name >  running_model >  name
              running_model: (cached && cached.MFILE) ? cached.MFILE : (d.loader_name || d.running_model || d.name || '')
            };
          }
        },
        // SN  4  16  3f-2d-4a-73
        formatSN(val) {
          if (!val) return '--';
          let num = Number(val);
          if (isNaN(num)) return String(val); // 
          //  16  8 4
          let hex = num.toString(16).padStart(8, '0').toLowerCase();
          //  2 
          const segments = [];
          for (let i = 0; i < hex.length; i += 2) {
            segments.push(hex.substring(i, i + 2));
          }
          return segments.join('-');
        },
        //  get_signals  name->value map
        signalsToMap(resp) {
          const payload = (resp && resp.data !== undefined) ? resp.data : resp;
          const list = Array.isArray(payload) ? payload : (payload && Array.isArray(payload.data) ? payload.data : []);
          const map = new Map();
          for (const it of list) {
            if (!it || it.name === undefined) continue;
            map.set(String(it.name), it.value);
          }
          // {name,value}
          if (!list.length && payload && payload.name !== undefined && payload.value !== undefined) {
            map.set(String(payload.name), payload.value);
          }
          if (!list.length && payload && payload.data && payload.data.name !== undefined && payload.data.value !== undefined) {
            map.set(String(payload.data.name), payload.data.value);
          }
          return map;
        },

        // --- Sheet  ---
        loadRegisterSheets() {
          try {
            const saved = localStorage.getItem('xloader_register_sheets');
            if (saved) {
              const sheets = JSON.parse(saved);
              //  root sheet 
              if (!sheets.find(s => s.id === 'root')) {
                sheets.unshift({ id: 'root', name: '', registerNames: [], timerEnabled: false, timerInterval: 5000, timerId: null });
              }
              //  timerId
              sheets.forEach(s => s.timerId = null);
              this.registerSheets = sheets;
            }
          } catch (e) {
            console.error('[Sheet] Load failed:', e);
          }
        },
        saveRegisterSheets() {
          try {
            const toSave = this.registerSheets.map(s => ({
              id: s.id,
              name: s.name,
              registerNames: s.registerNames,
              timerEnabled: s.timerEnabled,
              timerInterval: s.timerInterval
            }));
            localStorage.setItem('xloader_register_sheets', JSON.stringify(toSave));
          } catch (e) {
            console.error('[Sheet] Save failed:', e);
          }
        },
        handleSheetAdd() {
          if (this.registerSheets.length >= 5) {
            this.$message.warning(' 5 ');
            return;
          }
          this.newSheetName = '';
          this.dialogAddSheetVisible = true;
        },
        handleSheetRemove(targetName) {
          if (targetName === 'root') return;
          this.$confirm('', '', { type: 'warning' }).then(() => {
            const idx = this.registerSheets.findIndex(s => s.id === targetName);
            if (idx !== -1) {
              const sheet = this.registerSheets[idx];
              if (sheet.timerId) clearInterval(sheet.timerId);
              this.registerSheets.splice(idx, 1);
              if (this.activeSheetId === targetName) this.activeSheetId = 'root';
              this.saveRegisterSheets();
            }
          }).catch(() => {
            // 
          });
        },
        confirmAddSheet() {
          const name = this.newSheetName.trim();
          if (!name) return;
          const id = 'sheet_' + Date.now();
          this.registerSheets.push({
            id,
            name,
            registerNames: [],
            timerEnabled: false,
            timerInterval: 5000,
            timerId: null
          });
          this.activeSheetId = id;
          this.dialogAddSheetVisible = false;
          this.saveRegisterSheets();
        },
        renameSheet(sheet) {
          if (sheet.id === 'root') return;
          this.$prompt(' Sheet ', '', {
            inputValue: sheet.name,
            inputPattern: /\S+/,
            inputErrorMessage: ''
          }).then(({ value }) => {
            sheet.name = value;
            this.saveRegisterSheets();
          });
        },
        async toggleSheetTimer(sheet) {
          // el-switch  @change  v-model 
          //  sheet.timerEnabled 
          const shouldEnable = sheet.timerEnabled;
          
          if (!shouldEnable) {
            // 
            sheet.timerId = null;
            // 
            if (this.wsConnected) {
              try {
                await wsClient.stopRefreshRegs();
                console.log('[Sheet] :', sheet.name);
              } catch (err) {
                console.error('[Sheet] :', err);
                // 
                this.$set(sheet, 'timerEnabled', true);
                return;
              }
            }
            // 
            this.$set(sheet, 'timerEnabled', false);
          } else {
            //  Sheet 
            for (const s of this.registerSheets) {
              if (s.id !== sheet.id && s.timerEnabled) {
                s.timerId = null;
                this.$set(s, 'timerEnabled', false);
                // 
                if (this.wsConnected) {
                  try {
                    await wsClient.stopRefreshRegs();
                    console.log('[Sheet] :', s.name);
                  } catch (err) {
                    console.error('[Sheet] :', err);
                  }
                }
              }
            }
            
            // 
            this.$set(sheet, 'timerEnabled', true);
            this.startSheetTimer(sheet);
          }
          this.saveRegisterSheets();
        },
        startSheetTimer(sheet) {
          // 
          if (sheet.timerId) {
            clearInterval(sheet.timerId);
            sheet.timerId = null;
          }
          
          //  WebSocket 豸
          if (!this.wsConnected || !this.deviceConnected) {
            return;
          }
          
          const names = sheet.id === 'root' ? this.registers.map(r => r.name) : sheet.registerNames;
          if (!names.length) {
            return;
          }
          
          const period = sheet.timerInterval || 5000;
          
          try {
            // 31
            wsClient.scheduleRefreshSignals(this.device_id, this.loader_num, names, period).then(() => {
              console.log('[Sheet] : ' + sheet.name + ', : ' + period + 'ms');
            }).catch(err => {
              console.error(`[Sheet] :`, err);
            });
          } catch (err) {
            console.error(`[Sheet] :`, err);
          }
        },
        async refreshSheetRegisters(sheet) {
          if (!this.deviceConnected) return;
          const names = sheet.id === 'root' ? this.registers.map(r => r.name) : sheet.registerNames;
          if (!names.length) return;
          
          try {
            // 6
            const resp = await wsClient.getSignals(this.device_id, this.loader_num, names);
            const m = this.signalsToMap(resp);
            
            // 
            this.registers.forEach(reg => {
              if (names.includes(reg.name) && m.has(reg.name)) {
                reg.value = m.get(reg.name);
                reg.readError = false;
              }
            });
          } catch (e) {
            console.warn('[Sheet] Auto-refresh failed:', e);
          }
        },
        // ---  /  ---
        handleDragStart(event, reg, index) {
          event.dataTransfer.setData('type', 'register');
          event.dataTransfer.setData('regName', reg.name);
          event.dataTransfer.setData('fromSheetId', this.activeSheetId);
          event.dataTransfer.setData('fromIndex', index);
          this.draggedRegName = reg.name;
        },
        handleTabDragStart(event, index) {
          if (this.registerSheets[index].id === 'root') return;
          event.dataTransfer.setData('type', 'tab');
          event.dataTransfer.setData('fromTabIndex', index);
        },
        handleDragOverRow(event, index) {
          if (this.activeSheetId === 'root') return;
          this.dragOverRowIndex = index;
        },
        handleTabDragOver(event, index) {
          this.dragOverTabIndex = index;
        },
        handleTabDragLeave(event) {
          this.dragOverTabIndex = null;
        },
        handleDropOnRow(event, targetIndex) {
          this.dragOverRowIndex = null;
          const type = event.dataTransfer.getData('type');
          if (type !== 'register') return;

          const fromSheetId = event.dataTransfer.getData('fromSheetId');
          const regName = event.dataTransfer.getData('regName');

          if (this.activeSheetId === 'root' || fromSheetId !== this.activeSheetId) return;

          //  Sheet  registerNames 
          const sheet = this.currentSheet;
          const names = [...sheet.registerNames];
          
          const targetReg = this.filteredRegisters[targetIndex];
          if (!targetReg) return;
          
          const realFromIndex = names.indexOf(regName);
          const realTargetIndex = names.indexOf(targetReg.name);

          if (realFromIndex !== -1 && realTargetIndex !== -1) {
            const [movedName] = names.splice(realFromIndex, 1);
            names.splice(realTargetIndex, 0, movedName);
            sheet.registerNames = names;
            this.saveRegisterSheets();
          }
        },
        handleDropOnTab(event, targetIndex) {
          this.dragOverTabIndex = null;
          const type = event.dataTransfer.getData('type');
          const targetSheet = this.registerSheets[targetIndex];
          if (!targetSheet) return;

          if (type === 'tab') {
            // 
            const fromIndex = parseInt(event.dataTransfer.getData('fromTabIndex'));
            if (isNaN(fromIndex) || fromIndex === targetIndex || targetSheet.id === 'root') return;
            
            const sheets = [...this.registerSheets];
            const [moved] = sheets.splice(fromIndex, 1);
            sheets.splice(targetIndex, 0, moved);
            this.registerSheets = sheets;
            this.saveRegisterSheets();
          } else if (type === 'register') {
            // 
            const regName = event.dataTransfer.getData('regName');
            const fromSheetId = event.dataTransfer.getData('fromSheetId');
            if (!regName || fromSheetId === targetSheet.id) return;
            
            if (!targetSheet.registerNames.includes(regName)) {
              targetSheet.registerNames.push(regName);
              this.saveRegisterSheets();
              this.$message.success(': ' + targetSheet.name);
            }
          }
        },
        
        // ---  ---
        showContextMenu(event, reg) {
          this.contextMenuReg = reg;
          this.contextMenuPos = { x: event.clientX, y: event.clientY };
          this.contextMenuVisible = true;
          
          const hideMenu = () => {
            this.contextMenuVisible = false;
            document.removeEventListener('click', hideMenu);
          };
          document.addEventListener('click', hideMenu);
        },
        addRegToSheet(reg, sheetId) {
          const sheet = this.registerSheets.find(s => s.id === sheetId);
          if (sheet && reg) {
            if (!sheet.registerNames.includes(reg.name)) {
              sheet.registerNames.push(reg.name);
              this.saveRegisterSheets();
              this.$message.success(': ' + sheet.name);
            } else {
              this.$message.warning('');
            }
          }
          this.contextMenuVisible = false;
        },
        removeRegFromCurrentSheet(reg) {
          if (this.activeSheetId === 'root' || !reg) return;
          const sheet = this.currentSheet;
          sheet.registerNames = sheet.registerNames.filter(n => n !== reg.name);
          this.saveRegisterSheets();
          this.$message.success('');
          this.contextMenuVisible = false;
        },

        async refreshDeviceInfoFromSignals() {
          if (!this.wsConnected) return;
          try {
            // /
            if (!this.deviceConnected) {
              this.isModelRunning = false;
              this.runningFile = '';
              return;
            }

            // 
            const essentialRegs = ['NAME', 'VERSION', 'HVERSION', 'SN', 'MFILE'];
            let m = new Map();
            try {
              const resp = await wsClient.getSignals(this.device_id, this.loader_num, essentialRegs);
              m = this.signalsToMap(resp);
            } catch (err) {
              console.warn('[DeviceInfo] Failed to get essential registers:', err);
            }

            // VERSION/HVERSION/NAME/SN/MFILE show:false豸
            const name = m.get('NAME');
            const version = m.get('VERSION');
            const hversion = m.get('HVERSION');
            const sn = m.get('SN');
            const mfile = m.get('MFILE');

            if (name !== undefined && name !== null && String(name).trim()) {
              this.deviceNameFromRegister = String(name);
            }
            if (sn !== undefined && sn !== null && String(sn).trim()) {
              const formatted = this.formatSN(sn);
              this.deviceInfo.sn = formatted;
              this.deviceSN = String(sn); //  SN formatted 
            }
            if (hversion !== undefined && hversion !== null && String(hversion).trim()) {
              this.deviceInfo.hardwareVersion = String(hversion);
            }
            if (version !== undefined && version !== null && String(version).trim()) {
              this.deviceInfo.softwareVersion = String(version);
            }
            //  MFILE 
            const f = mfile !== undefined && mfile !== null ? String(mfile).trim() : '';
            const k = this.otaKey(this.device_id, this.loader_num);
            this.$set(this.deviceSignalCache, k, { ...(this.deviceSignalCache[k] || {}), MFILE: f });
            
            //  MFILE    
            // "->""->""FAIL:MFILE"
            const isFailMfile = (str) => {
              if (!str) return false;
              const upperStr = String(str).toUpperCase();
              const arrowIndex = upperStr.indexOf('->');
              if (arrowIndex !== -1) {
                const beforeArrow = upperStr.substring(0, arrowIndex).trim();
                return beforeArrow === 'FAIL:MFILE';
              }
              return false;
            };
            
            if (!f || f.toLowerCase().includes('example') || isFailMfile(f)) {
              this.isModelRunning = false;
              this.runningFile = '';
            } else {
              this.isModelRunning = true;
              this.runningFile = f;
            }
                  } catch (err) {
            // 
            this.isModelRunning = false;
            this.runningFile = '';
          }
        },

        // /
        openModelDialog() { this.dialogModelVisible = true; this.loadModelTree(); },
        openUpgradeDialog() { this.dialogUpgradeVisible = true; },
        openLogDialog() { this.dialogLogVisible = true; this.loadLogTree(); },
        openConsoleDrawer() { this.drawerConsoleVisible = true; },

        toBool(v) {
          if (v === true) return true;
          if (v === false) return false;
          const s = String(v).toLowerCase().trim();
          return s === 'true' || s === '1' || s === 'yes' || s === 'y';
        },
        deviceLedClass(dev) {
          // /OTA
          const connected = dev && this.toBool(dev.connect);
          if (!connected) return '';
          
          // OTA 'running' 
          const k = this.getDeviceKey(dev);
          const otaSt = this.otaStatus[k];
          const isUpgrading = otaSt && otaSt.status === 'running';
          if (isUpgrading) return 'upgrading';
          
          const abnormal = this.toBool(dev.interrupt) || this.toBool(dev.high_temp_alarm) || this.toBool(dev.busy);
          if (abnormal) return 'alarm';
          
          // 
          const running = this.toBool(dev.running);
          if (running) return 'running';
          return 'connected';
        },
        getDeviceKey(dev) {
          if (!dev) return '';
          return String(dev.ip) + '#' + Number(dev.loader_num);
        },
        isSelectedDevice(dev) {
          return this.selectedDeviceKey && this.selectedDeviceKey === this.getDeviceKey(dev);
        },
        async selectDevice(dev) {
          if (!dev) return;
          
          // 豸
          const oldDeviceId = this.device_id;
          const oldLoaderNum = this.loader_num;
          
          // 
          const activeSheet = this.registerSheets.find(s => s.timerEnabled);
          
          // 豸豸
          if (this.wsConnected && activeSheet) {
            try {
              await wsClient.stopRefreshRegs();
              console.log('[Device] 豸豸');
            } catch (err) {
              console.error('[Device] :', err);
            }
          }
          
          //  start/stop/get_models 豸
          this.selectedDeviceKey = this.getDeviceKey(dev);
          if (dev.ip) this.device_id = String(dev.ip);
          if (Number.isFinite(Number(dev.loader_num))) this.loader_num = Number(dev.loader_num);
          // "豸"
          this.deviceConnected = !!dev.connect;
          //  connectStatus 豸
          this.syncDeviceInfoFromStatus(dev);
          
          // 豸豸
          if (activeSheet && (oldDeviceId !== this.device_id || oldLoaderNum !== this.loader_num)) {
            // 
            this.registerSheets.forEach(s => {
              if (s.timerEnabled) {
                s.timerId = null;
                this.$set(s, 'timerEnabled', false);
              }
            });
            
            // 豸
            if (this.deviceConnected && this.wsConnected && activeSheet.id === this.activeSheetId) {
              // 豸
              this.$nextTick(() => {
                this.$set(activeSheet, 'timerEnabled', true);
                this.startSheetTimer(activeSheet);
                console.log('[Device] 豸:', activeSheet.name);
              });
            }
          } else {
            // 豸
            this.registerSheets.forEach(s => {
              if (s.timerEnabled && s.timerId) {
                s.timerId = null;
                this.$set(s, 'timerEnabled', false);
              }
            });
          }
        },
        
        /**
         *  get_connect_status 豸
         *  running_model  running 
         */
        syncDeviceInfoFromStatus(entry) {
          if (!entry) {
            entry = this.currentDeviceEntry;
          }
          if (entry) {
            // 豸
            this.deviceInfo = {
              sn: this.formatSN(entry.sn || this.deviceInfo.sn),
              hardwareVersion: entry.hversion || this.deviceInfo.hardwareVersion || '',
              softwareVersion: entry.version || this.deviceInfo.softwareVersion || '',
              runTime: (entry.total_time !== undefined && entry.total_time !== null && String(entry.total_time) !== '')
                ? entry.total_time + ' h'
                : (this.deviceInfo.runTime || '')
            };
            if (entry.sn) this.deviceSN = String(entry.sn);
            if (entry.name) this.deviceNameFromRegister = String(entry.name);
            
            //  running  running_model 
            if (!this.deviceConnected) {
              this.isModelRunning = false;
              this.runningFile = '';
            } else {
              //  entry.running  entry.running_model
              const isRunning = entry.running === true || String(entry.running).toLowerCase() === 'true';
              const runningModel = entry.running_model || '';
              
              // running  true  running_model 
              // "->""->""FAIL:MFILE"
              const isFailMfile = (str) => {
                if (!str) return false;
                const upperStr = String(str).toUpperCase();
                const arrowIndex = upperStr.indexOf('->');
                if (arrowIndex !== -1) {
                  const beforeArrow = upperStr.substring(0, arrowIndex).trim();
                  return beforeArrow === 'FAIL:MFILE';
                }
                return false;
              };
              
              if (isRunning && runningModel && 
                  !runningModel.toLowerCase().includes('example') && 
                  !isFailMfile(runningModel)) {
                this.isModelRunning = true;
                this.runningFile = runningModel;
              } else {
                this.isModelRunning = false;
                this.runningFile = '';
              }
            }
          }
        },

        // ===========================
        // OTAsocket.md 14/15
        // ===========================
        otaKey(ip, loader_num) {
          return String(ip) + '#' + Number(loader_num);
        },
        getOtaProgress(ip, loader_num) {
          const k = this.otaKey(ip, loader_num);
          const v = this.otaProgress[k];
          return typeof v === 'number' ? v : 0;
        },
        getOtaProgressStatus(ip, loader_num) {
          const k = this.otaKey(ip, loader_num);
          const st = this.otaStatus[k] || {};
          if (st.status === 'success') return 'success';
          if (st.status === 'error' || st.status === 'failed') return 'exception';
          return undefined;
        },
        getOtaStatusText(ip, loader_num) {
          const k = this.otaKey(ip, loader_num);
          const st = this.otaStatus[k];
          if (st && st.desc) return st.desc;
          const p = this.getOtaProgress(ip, loader_num);
          if (p > 0 && p < 100) return ' ' + p.toFixed(1) + '%';
          return '';
        },
        async checkCloudNewVersion() {
          if (!this.wsConnected) return;
          this.otaLoading = true;
          try {
            const resp = await wsClient.checkLoadersNewVersion();
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) throw new Error(payload.desc || 'check failed');
            const desc = (payload && payload.desc) || [];
            this.otaGroups = Array.isArray(desc) ? desc : [];
            this.otaCloudCheckedAt = new Date().toLocaleString();
            this.otaCloudMsg = '';
            this.otaCloudStatus = this.otaGroups.length ? 'ok' : 'empty';
            //  progress
            for (const grp of this.otaGroups) {
              for (const d of (grp.devices || [])) {
                const k = this.otaKey(grp.ip, d.loader_num);
                const p = Number(d.progress);
                if (Number.isFinite(p)) this.$set(this.otaProgress, k, p);
              }
            }
            this.$message.success('汾');
          } catch (err) {
            this.otaCloudCheckedAt = new Date().toLocaleString();
            this.otaCloudStatus = 'error';
            this.otaCloudMsg = (err && err.message) ? err.message : String(err);
            this.$message.error(': ' + (err.message || err));
          } finally {
            this.otaLoading = false;
          }
        },
        async startOta(ip, loader_num) {
          if (!this.wsConnected) return;
          const k = this.otaKey(ip, loader_num);
          this.otaUpdatingKey = k;
          this.$set(this.otaStatus, k, { status: 'running', desc: '' });
          try {
            const resp = await wsClient.updateOneLoader(String(ip), Number(loader_num));
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) throw new Error(payload.desc || 'update failed');
            //  update_ota_progress 
            this.$message.success('');
          } catch (err) {
            this.$set(this.otaStatus, k, { status: 'error', desc: err.message || '' });
            this.$message.error(': ' + (err.message || err));
          } finally {
            this.otaUpdatingKey = '';
          }
        },

        //  hex 
        onHexSelected(file, fileList) {
          const name = (file && file.name) ? String(file.name) : '';
          if (!name.toLowerCase().endsWith('.hex')) {
            this.$message.error(' .hex ');
            this.hexFileList = [];
            this.selectedHexFile = null;
            this.selectedHexName = '';
            this.selectedHexPath = '';
            return;
          }
          // ElementUI  file  raw  File
          this.selectedHexFile = file.raw || null;
          this.selectedHexName = name;
          this.hexFileList = fileList.slice(-1);
          // 
          this.selectedHexPath = '';
        },
        onHexRemoved() {
          this.selectedHexFile = null;
          this.selectedHexName = '';
          this.selectedHexPath = '';
          this.hexFileList = [];
        },
        openLocalUpgrade(row) {
          this.localUpgradeTarget = {
            ip: row.ip,
            loader_num: row.loader_num,
            loader_name: row.loader_name || ''
          };
          this.selectedHexFile = null;
          this.selectedHexName = '';
          this.selectedHexPath = '';
          this.localUpgradePath = '';
          this.hexFileList = [];
          this.localUpgradeTab = 'file';
          this.dialogLocalUpgradeVisible = true;
        },
        async confirmLocalUpgrade() {
          let filePath = '';
          
          // 
          if (this.localUpgradeTab === 'file') {
            // 
            if (!this.selectedHexFile || !this.selectedHexName) {
              this.$message.warning(' .hex ');
              return;
            }
            
            // 
            try {
              this.localUpgradeLoading = true;
              const formData = new FormData();
              formData.append('file', this.selectedHexFile);
              
              const uploadResp = await fetch('/api/upload/hex', {
                method: 'POST',
                body: formData
              });
              
              if (!uploadResp.ok) {
                throw new Error('');
              }
              
              const uploadResult = await uploadResp.json();
              if (uploadResult && uploadResult.path) {
                filePath = uploadResult.path;
              } else {
                throw new Error('');
              }
            } catch (err) {
              this.localUpgradeLoading = false;
              this.$message.error(': ' + (err.message || err) + '""');
              this.localUpgradeTab = 'path';
              this.localUpgradePath = this.selectedHexName;
              return;
            }
          } else {
            // 
            filePath = (this.localUpgradePath || '').trim();
            if (!filePath) {
              this.$message.warning(' .hex ');
              return;
            }
            if (!filePath.toLowerCase().endsWith('.hex')) {
              this.$message.warning(' .hex ');
              return;
            }
          }
          
          // 
          if (this.localUpgradeLoading) {
            return;
          }
          
          // 
          this.dialogLocalUpgradeVisible = false;
          this.localUpgradeLoading = true;
          
          // 
          const k = this.otaKey(this.localUpgradeTarget.ip, this.localUpgradeTarget.loader_num);
          
          try {
            //  loader_ota 
            const resp = await wsClient.loaderOta(
              this.localUpgradeTarget.ip,
              this.localUpgradeTarget.loader_num,
              filePath
            );
            
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) {
              throw new Error(payload.desc || '');
            }
            
            // 
            this.$message.success('');
            this.$set(this.otaStatus, k, { status: 'running', desc: '' });
            this.otaUpdatingKey = k;
            
            // 
            this.selectedHexFile = null;
            this.selectedHexName = '';
            this.selectedHexPath = '';
            this.localUpgradePath = '';
            this.hexFileList = [];
          } catch (err) {
            // 
            this.$message.error(': ' + (err.message || err));
            // 
            if (this.otaStatus[k] && this.otaStatus[k].status === 'error') {
              this.$delete(this.otaStatus, k);
            }
            // 
            this.dialogLocalUpgradeVisible = true;
          } finally {
            this.localUpgradeLoading = false;
          }
        },

        // 
        pushConsole(dir, text) {
          const ts = new Date().toLocaleString();
          this.consoleHistory.push({ ts, dir, text: String(text !== undefined && text !== null ? text : '') });
          //  200 
          if (this.consoleHistory.length > 200) this.consoleHistory.splice(0, this.consoleHistory.length - 200);
        },
        async sendConsoleCmd() {
          try {
            const cmd = String(this.consoleInput || '').trim();
            if (!cmd) return;
            this.pushConsole('out', cmd);
            this.consoleInput = '';
            const resp = await wsClient.sendCmd(this.device_id, this.loader_num, cmd, false);
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            const desc = payload && payload.desc !== undefined ? payload.desc : JSON.stringify(payload);
            this.pushConsole('in', desc);
          } catch (err) {
            this.pushConsole('in', 'ERROR: ' + (err.message || err));
          }
        },

        // 豸get_file_info(project*)  (log/)
        normalizeTree(node) {
          if (!node) return null;
          if (Array.isArray(node)) return node.map(n => this.normalizeTree(n)).filter(Boolean);
          const label = node.label !== undefined ? String(node.label) : (node.name !== undefined ? String(node.name) : '');
          const children = Array.isArray(node.children) ? node.children : [];
          return { label, children: children.map(c => this.normalizeTree(c)).filter(Boolean) };
        },
        findNodeByLabel(nodes, label) {
          const list = Array.isArray(nodes) ? nodes : [];
          for (const n of list) {
            if (!n) continue;
            if (String(n.label) === String(label)) return n;
            const hit = this.findNodeByLabel(n.children, label);
            if (hit) return hit;
          }
          return null;
        },
        async loadFileTreeRoot() {
          if (!this.wsConnected) return [];
          const resp = await wsClient.getFileInfo(this.device_id, this.loader_num, '');
          const payload = (resp && resp.data !== undefined) ? resp.data : resp;
          const norm = this.normalizeTree(payload);
          if (Array.isArray(norm)) return norm;
          if (norm && (norm.label || (norm.children && norm.children.length))) return [norm];
          return [];
        },
        async loadModelTree() {
          this.modelTreeLoading = true;
          try {
            const roots = await this.loadFileTreeRoot();
            const root = roots[0] || null;
            const children = root && Array.isArray(root.children) ? root.children : roots;
            //  project* log
            const projects = (children || []).filter(n => n && n.label && n.label.toLowerCase() !== 'log');
            this.modelTreeData = projects;
          } catch (err) {
            this.modelTreeData = [];
          } finally {
            this.modelTreeLoading = false;
          }
        },
        async loadLogTree() {
          this.logTreeLoading = true;
          try {
            const roots = await this.loadFileTreeRoot();
            const root = roots[0] || null;
            const children = root && Array.isArray(root.children) ? root.children : roots;
            const logNode = this.findNodeByLabel(children || [], 'log');
            if (logNode) this.logTreeData = logNode.children || [];
            else {
              // fallback name='log'
              const resp = await wsClient.getFileInfo(this.device_id, this.loader_num, 'log');
              const payload = (resp && resp.data !== undefined) ? resp.data : resp;
              const norm = this.normalizeTree(payload);
              this.logTreeData = Array.isArray(norm) ? norm : (norm && norm.children ? norm.children : []);
            }
          } catch (err) {
            this.logTreeData = [];
          } finally {
            this.logTreeLoading = false;
          }
        },
        handleLogNodeClick(data, node) {
          // 
          if (!node.isLeaf) {
            this.selectedLogPath = '';
            return;
          }
          // log/
          const path = this.buildLogPath(node);
          this.selectedLogPath = path;
        },
        buildLogPath(node) {
          // 
          const pathParts = [];
          let current = node;
          while (current) {
            if (current.label) {
              pathParts.unshift(current.label);
            }
            current = current.parent;
          }
          return pathParts.join('/');
        },
        async confirmPullLog() {
          if (!this.selectedLogPath) {
            this.$message.warning('');
            return;
          }
          
          try {
            const resp = await wsClient.pullFile(this.device_id, this.loader_num, this.selectedLogPath);
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) {
              throw new Error(payload.desc || '');
            }
            this.$message.success((payload && payload.desc) || '');
            this.selectedLogPath = '';
          } catch (err) {
            this.$message.error(': ' + (err.message || err));
          }
        },

        async loadDeviceSpecsConfig() {
          try {
            const resp = await fetch('device_specs.json');
            this.deviceSpecsConfig = await resp.json();
          } catch (err) {
            console.warn('[spec] load device_specs.json failed:', err);
            this.deviceSpecsConfig = null;
          }
        },

        async tryReadDeviceNameFromRegister() {
          // EL-5000 NAME 
          //  register_definitions.json  name=NAME 
          try {
            const regDef = (this.registerDefsAll || this.registers || []).find(r => r && r.name === 'NAME');
            if (!regDef) return;
            const resp = await wsClient.getSignals(this.device_id, this.loader_num, regDef.name);
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            // {name:"CCV",value:"100"} / {data:{name:"CCV",value:"100"}} / {data:[...]} / 
            let val = null;
            if (payload && payload.value !== undefined) val = payload.value;
            else if (payload && payload.data && payload.data.value !== undefined) val = payload.data.value;
            else if (Array.isArray(payload)) {
              const item = payload.find(x => x && x.name === regDef.name);
              if (item && item.value !== undefined) val = item.value;
            } else if (payload && Array.isArray(payload.data)) {
              const item = payload.data.find(x => x && x.name === regDef.name);
              if (item && item.value !== undefined) val = item.value;
            }
            if (val !== undefined && val !== null) {
              this.deviceNameFromRegister = String(val);
            }
          } catch (err) {
            // 
          }
        },
        async loadLocationInfo() {
          try {
            const resp = await wsClient.queryLocationInfo();
            // 
            const payload = resp && resp.data ? resp.data : resp;
            if (payload && payload.location_list) {
              this.locationList = payload.location_list || [];
              const registered = payload.loader_location || '';
              if (registered) {
                this.selectedLocation = registered;
                this.isLocationRegistered = true;
              } else {
                // 
                this.selectedLocation = '';
                this.isLocationRegistered = false;
              }
            }
          } catch (err) {
            console.warn('[ws] query_location_info failed:', err);
            // 
            this.selectedLocation = '';
            this.isLocationRegistered = false;
          }
        },

        async handleSaveLocation() {
          if (!this.selectedLocation || this.selectedLocation === '') {
            this.$message.warning('');
            return;
          }
          try {
            const resp = await wsClient.saveLocationInfo(this.selectedLocation);
            const payload = resp && resp.data ? resp.data : resp;
            if (payload && (payload.ret === true || payload.ret === 'true')) {
              this.$message.success('');
              this.isLocationRegistered = true;
            } else {
              this.$message.error((payload && payload.desc) || '');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },

        onLocationChanged() {
          // 
        },

        /**
         * get_models
         *  data: { ret:true, desc:[{value,label,children:[...]}] }
         */
        async refreshModelOptions() {
          this.modelOptionsLoading = true;
          try {
            const resp = await wsClient.getModels(this.device_id, this.loader_num, this.currentSimType);
            const payload = resp && resp.data ? resp.data : resp; // 
            const ok = payload && (payload.ret === true || payload.ret === 'true');
            if (!ok) {
              this.$message.error((payload && payload.desc) || '');
              this.modelOptions = [];
              return;
            }
            this.modelOptions = payload.desc || [];
            this.$message.success('');
            //  refreshDeviceInfoFromSignals 
          } catch (err) {
            this.$message.error(': ' + err.message);
          } finally {
            this.modelOptionsLoading = false;
          }
        },

        async startSelectedModel() {
          if (!this.canStartSelected) {
            this.$message.warning('/');
            return;
          }
          try {
            const resp = await wsClient.startLoader(this.device_id, this.loader_num, this.selectedModelPath, this.currentSimType);
            const payload = resp && resp.data ? resp.data : resp;
            if (payload && payload.ret === false) {
              this.$message.error(payload.desc || '');
            } else {
              this.$message.success((payload && payload.desc) || '');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },

        async stopSelectedModel() {
          if (!this.canStopSelected) {
            this.$message.warning('');
            return;
          }
          try {
            //  selectedModelPath
            const modelPath = this.runningFile || (Array.isArray(this.selectedModelPath) && this.selectedModelPath.length >= 2 ? this.selectedModelPath : ['project1', 'model']);
            
            //  data_replay
            let resp = await wsClient.stopLoader(this.device_id, this.loader_num, modelPath, 'data_replay');
            let payload = resp && resp.data ? resp.data : resp;
            
            //  data_replay  component_emulation
            if (payload && payload.ret === false) {
              console.log('[WS] data_replay  component_emulation');
              resp = await wsClient.stopLoader(this.device_id, this.loader_num, modelPath, 'component_emulation');
              payload = resp && resp.data ? resp.data : resp;
            }
            
            // 
            if (payload && payload.ret === false) {
              this.$message.error(payload.desc || '');
            } else {
              // MFILE
              this.isModelRunning = false;
              this.runningFile = '';
              this.$message.success((payload && payload.desc) || '');
              //  refreshDeviceInfoFromSignals
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        /**
         * /鶨壩
         * model_dictionary.json
         *  WS/API 
         */
        async loadModelDictionary() {
          try {
            // 1)  jsoncs/ 
            try {
              const resp = await fetch('model_dictionary.json', { cache: 'no-cache' });
              if (resp.ok) {
                const json = await resp.json();
                if (json && json.parameters && json.modules) {
                  this.modelDictionary = { parameters: json.parameters, modules: json.modules };
                  modelDictionary = this.modelDictionary;
                  return;
                }
              }
            } catch (e) {}

            // 2) WS 
            if (this.wsConnected) {
              const data = await wsClient.request('model.dictionary');
              if (data && data.parameters && data.modules) {
                this.modelDictionary = { parameters: data.parameters, modules: data.modules };
                modelDictionary = this.modelDictionary;
                return;
              }
            }

            // 3) HTTP API 
            const resp = await fetch('/api/model/dictionary');
            const json = await resp.json();
            if (json && json.parameters && json.modules) {
              this.modelDictionary = { parameters: json.parameters, modules: json.modules };
              modelDictionary = this.modelDictionary;
            }
          } catch (err) {
            console.warn('[model] loadModelDictionary failed:', err);
          }
        },
        /**
         * 
         * register_definitions.json
         *  WS/API 
         */
        async loadRegisterDefinitions() {
          try {
            let defs = null;
            // 1)  json
            try {
              const resp = await fetch('register_definitions.json', { cache: 'no-cache' });
              if (resp.ok) {
                const json = await resp.json();
                defs = json && json.definitions;
              }
            } catch (e) {}

            // 2) WS 
            if (!defs && this.wsConnected) {
              const data = await wsClient.request('register.definitions');
              defs = data && data.definitions;
            }

            // 3) HTTP API 
            if (!defs) {
              const resp = await fetch('/api/register/definitions');
              const json = await resp.json();
              defs = json && json.definitions;
            }

            if (!Array.isArray(defs)) return;

            // 
            this.registerDefsAll = defs;

            this.registers = defs.map(d => ({
              // register_definitions.json  address  id "0x0000"
              address: (typeof d.address === 'number')
                ? d.address
                : (typeof d.id === 'string' && d.id.startsWith('0x'))
                  ? parseInt(d.id, 16)
                  : (typeof d.id === 'number' ? d.id : 0),
              name: d.name,
              type: d.type,
              access: d.access,
              description: d.description || '',
              min: typeof d.min === 'number' ? d.min : null,
              max: typeof d.max === 'number' ? d.max : null,
              value: null,
              inputValue: null,
              loading: false,
              modified: false,
              readError: false
            }));
          } catch (err) {
            console.warn('[register] loadRegisterDefinitions failed:', err);
          }
        },

        /**
         * 
         * WebSocket: get_local_file_list
         */
        async parseAllFiles() {
          try {
            // 
            await this.loadModelDictionary();

            if (this.wsConnected) {
              try {
                // 
                const resp = await wsClient.getLocalFileList();
                const payload = resp && resp.data ? resp.data : resp;
                
                // 
                if (payload && payload.ret === true && Array.isArray(payload.desc) && payload.desc.length > 0) {
                  // 
                  this.models = payload.desc.map(file => ({
                    filename: file.filename || file.name || 'unknown.bin',
                    path: file.path || file.filename || file.name || 'unknown.bin',
                    success: false, // 
                    modules: [],
                    raw: '',
                    modified: false,
                    errors: [],
                    warnings: []
                  }));
                  this.activeModelIndex = -1; // 
                  console.log('[] ', this.models.length, '');
                  return;
                } else {
                  console.warn('[] :', payload);
                  // 
                  this.models = [];
                  this.activeModelIndex = -1;
                  return;
                }
              } catch (wsErr) {
                console.error('[] :', wsErr);
                // WebSocket 
                this.models = [];
                this.activeModelIndex = -1;
                return;
              }
            }
            
            //  WebSocket 
            await this.loadSampleFiles();
            this.activeModelIndex = 0;
            this.expandedModules = { 0: true, 1: true };
          } catch (err) {
            console.error(':', err);
            // 
            this.models = [];
            this.activeModelIndex = -1;
          }
        },
        
        /**
         * 
         */
        async loadSampleFiles() {
          const models = [];
          for (const filename of Object.keys(sampleFiles)) {
            //  parseBinByServer /
            const parsed = await parseBinByServer(filename);
            models.push(parsed && parsed.success ? parsed : { success: false, filename, modules: [], errors: parsed.errors || [{ message: parsed.error || '', lineNum: 0 }], warnings: [], raw: sampleFiles[filename] });
          }
          this.models = models;
          console.log('[] ');
        },
        async selectModel(index) {
          this.activeModelIndex = index;
          const model = this.models[index];
          if (!model) return;
          
          // 
          if (!model.success && model.path && this.wsConnected) {
            try {
              model.loading = true;
              const resp = await wsClient.readLocalFile(model.path);
              const payload = resp && resp.data ? resp.data : resp;
              
              if (payload && payload.ret === true && payload.data) {
                const content = payload.data.content || '';
                if (!content) {
                  throw new Error('');
                }
                
                //  HTTP API 
                const parseResp = await fetch('/api/bin/parse', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ content, filename: model.filename })
                });
                
                if (!parseResp.ok) {
                  throw new Error(': ' + parseResp.status);
                }
                
                const parsed = await parseResp.json();
                
                if (parsed && parsed.success) {
                  Object.assign(model, {
                    ...parsed,
                    raw: content,
                    path: model.path,
                    modified: false,
                    loading: false
                  });
                } else {
                  Object.assign(model, {
                    success: false,
                    raw: content,
                    modules: [],
                    errors: parsed && (parsed.errors || [{ message: parsed.error || '', lineNum: 0 }]),
                    warnings: parsed && (parsed.warnings || []),
                    path: model.path,
                    modified: false,
                    loading: false
                  });
                  this.$message.warning(' ' + model.filename + ' ');
                }
              } else {
                throw new Error((payload && payload.desc) || '');
              }
            } catch (err) {
              console.error(':', err);
              model.loading = false;
              model.success = false;
              model.errors = [{ message: err.message || '', lineNum: 0 }];
              this.$message.error(': ' + (err.message || err));
            }
          }
          
          this.showRaw = false;
          this.hasModified = false;
          if (this.currentModel && this.isFileRunning(this.currentModel.filename)) {
            const runningModuleIndex = this.currentModel.modules.findIndex(m => m.name === this.runningModule);
            if (runningModuleIndex !== -1) this.expandedModules = { [runningModuleIndex]: true };
          } else {
            this.expandedModules = { 0: true };
          }
        },
        toggleModule(index) { this.$set(this.expandedModules, index, !this.expandedModules[index]); },
        updateArrayParam(mod, param, value) {
          param.value = value.trim().split(/\s+/).map(v => {
            const num = parseFloat(v);
            return isNaN(num) ? v : num;
          });
          this.hasModified = true;
        },
        toggleConnect() {
          this.deviceConnected = !this.deviceConnected;
          if (!this.deviceConnected) this.isModelRunning = false;
        },
        isFileRunning(filename) { return this.isModelRunning && this.runningFile === filename; },
        isModuleRunning(filename, moduleName) { return this.isFileRunning(filename) && this.runningModule === moduleName; },
        
        // 
        //  data/model_dictionary.json
        getParamDef(paramName) { return (this.modelDictionary && this.modelDictionary.parameters || {})[paramName]; },
        getModuleDef(moduleName) { return (this.modelDictionary && this.modelDictionary.modules || {})[moduleName]; },
        getModuleDisplayName(moduleName) {
          const def = this.getModuleDef(moduleName);
          return def ? (def.name + ' (' + moduleName + ')') : moduleName;
        },
        getPrecision(paramName) {
          const def = this.getParamDef(paramName);
          if (!def || !def.step) return 2;
          const str = def.step.toString();
          const decimal = str.indexOf('.');
          return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        isOutOfRange(param) {
          const def = this.getParamDef(param.name);
          if (!def || def.min === undefined || param.type !== 'single') return false;
          return param.value < def.min || param.value > def.max;
        },
        isNumericParam(param) {
          return typeof param.value === 'number' || !isNaN(parseFloat(param.value));
        },
        
        // 
        updateSingleParam(param, value) {
          //  null  undefined 0
          if (value === null || value === undefined || isNaN(value)) {
            const def = this.getParamDef(param.name);
            param.value = def && def.default !== undefined ? def.default : 0;
          } else {
            param.value = value;
          }
          this.hasModified = true;
        },
        
        // 
        addArrayItem(param) {
          const lastValue = param.value.length > 0 ? param.value[param.value.length - 1] : 0;
          param.value.push(typeof lastValue === 'number' ? 0 : '');
          this.hasModified = true;
        },
        removeArrayItem(param, index) {
          param.value.splice(index, 1);
          this.hasModified = true;
        },
        updateArrayItem(param, index, value) {
          if (value === null || value === undefined || isNaN(value)) {
            param.value[index] = 0;
          } else {
            param.value[index] = value;
          }
          this.hasModified = true;
        },
        updateArrayItemStr(param, index, value) {
          param.value[index] = value;
          this.hasModified = true;
        },
        
        // 
        addMatrixRow(param) {
          if (param.value.length > 0) {
            const cols = param.value[0].length;
            param.value.push(new Array(cols).fill(0));
          } else {
            param.value.push([0, 0, 0]);
          }
          this.hasModified = true;
        },
        removeMatrixRow(param, rowIndex) {
          if (param.value.length > 1) {
            param.value.splice(rowIndex, 1);
            this.hasModified = true;
          } else {
            this.$message.warning('');
          }
        },
        updateMatrixCell(param, rowIndex, colIndex, value) {
          if (value === null || value === undefined || isNaN(value)) {
            param.value[rowIndex][colIndex] = 0;
          } else {
            param.value[rowIndex][colIndex] = value;
          }
          this.hasModified = true;
        },
        
        // ============================================================
        // API 
        //  Python 
        // ============================================================
        
        /**
         * 
         * WebSocket: file.save
         */
        async handleSave() {
          if (!this.currentModel || !this.currentModel.path) return;
          
          try {
            const content = this.generateBinContent();
            if (this.wsConnected) {
              await wsClient.saveLocalFile(this.currentModel.path, content);
              this.$message.success('浽');
            } else {
              console.log('[] :', this.currentModel.filename);
              this.$message.success(' ()');
            }
            this.hasModified = false;
            //  raw 
            this.currentModel.raw = content;
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * 
         * WebSocket: file.saveAs
         */
        async handleSaveAs() {
          if (!this.currentModel) return;
          
          try {
            const { value } = await this.$prompt(' project1/new_example.bin', '', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: this.currentModel.path ? this.currentModel.path.replace(/\.bin$/, '_copy.bin') : 'project1/new_example.bin'
            });
            
            const content = this.generateBinContent();
            if (this.wsConnected) {
              await wsClient.saveAsLocalFile(value, content);
              this.$message.success(' ' + value);
              // 
              await this.parseAllFiles();
              // 
              const idx = this.models.findIndex(m => m.path === value);
              if (idx !== -1) {
                await this.selectModel(idx);
              }
            } else {
              console.log('[] :', value);
              this.$message.success(' ' + value + ' ()');
            }
            this.hasModified = false;
          } catch (e) {
            // 
          }
        },

        // --- / ---
        handleCreateNewModel() {
          this.newModelFilename = '';
          this.dialogNewModelVisible = true;
        },
        async confirmCreateNewModel() {
          const name = this.newModelFilename.trim();
          if (!name) return;
          const filename = name.endsWith('.bin') ? name : name + '.bin';
          
          try {
            // 
            const content = '# New Model: ' + filename + '\n# Created at: ' + new Date().toLocaleString() + '\n';
            
            if (this.wsConnected) {
              // 浽 resource/loader/ 
              const path = filename;
              
              // 浽
              await wsClient.saveAsLocalFile(path, content);
              this.$message.success(' ' + filename + ' ');
              this.dialogNewModelVisible = false;
              
              // 
              await this.parseAllFiles();
              // 
              const idx = this.models.findIndex(m => m.path === path || m.filename === filename);
              if (idx !== -1) {
                await this.selectModel(idx);
              }
            } else {
              // 
              this.models.push({
                filename,
                path: filename,
                raw: content,
                modules: [],
                success: true,
                modified: false
              });
              this.$message.success(' ' + filename + '  ()');
              this.dialogNewModelVisible = false;
              // 
              const idx = this.models.findIndex(m => m.filename === filename);
              if (idx !== -1) this.activeModelIndex = idx;
            }
          } catch (err) {
            this.$message.error(': ' + (err.message || err));
          }
        },
        handleOpenAddModuleDialog() {
          if (!this.currentModel) return;
          this.selectedModuleType = '';
          this.dialogAddModuleVisible = true;
        },
        getModuleDesc(type) {
          if (!type || !this.modelDictionary || !this.modelDictionary.modules || !this.modelDictionary.modules[type]) return '';
          return this.modelDictionary.modules[type].description || '';
        },
        confirmAddModule() {
          if (!this.selectedModuleType || !this.currentModel) return;
          
          const modDef = this.modelDictionary.modules[this.selectedModuleType];
          if (!modDef) return;
          
          // 幹
          const newModule = {
            name: this.selectedModuleType,
            params: []
          };
          
          // 
          if (modDef.parameters && Array.isArray(modDef.parameters)) {
            modDef.parameters.forEach(pName => {
              const pDef = this.modelDictionary.parameters[pName];
              if (pDef) {
                let initialValue;
                if (pDef.type === 'array') {
                  initialValue = pDef.default !== undefined ? [...pDef.default] : [];
                } else if (pDef.type === 'matrix') {
                  initialValue = pDef.default !== undefined ? pDef.default.map(row => [...row]) : [[0, 0, 0]];
                } else {
                  initialValue = pDef.default !== undefined ? pDef.default : (pDef.min !== undefined ? pDef.min : 0);
                }
                
                newModule.params.push({
                  name: pName,
                  type: pDef.type || 'single',
                  value: initialValue
                });
              }
            });
          }
          
          // 
          if (!this.currentModel.modules) this.$set(this.currentModel, 'modules', []);
          this.currentModel.modules.push(newModule);
          this.hasModified = true;
          this.dialogAddModuleVisible = false;
          
          // 
          const newIdx = this.currentModel.modules.length - 1;
          this.$set(this.expandedModules, newIdx, true);
          
          this.$message.success(': ' + this.selectedModuleType);
        },
        handleOpenAddParamDialog(moduleIndex) {
          if (!this.currentModel || !this.currentModel.modules || moduleIndex < 0) return;
          const module = this.currentModel.modules[moduleIndex];
          if (!module) return;
          
          // 
          if (this.isFileRunning(this.currentModel.filename) && this.runningModule === module.name) {
            this.$message.warning('');
            return;
          }
          
          this.selectedModuleIndexForParam = moduleIndex;
          this.selectedParamName = '';
          this.dialogAddParamVisible = true;
        },
        confirmAddParam() {
          if (!this.selectedParamName || this.selectedModuleIndexForParam < 0 || !this.currentModel) return;
          
          const module = this.currentModel.modules[this.selectedModuleIndexForParam];
          if (!module) return;
          
          // 
          if (module.params.some(p => p.name === this.selectedParamName)) {
            this.$message.warning('');
            return;
          }
          
          // 
          const pDef = (this.modelDictionary && this.modelDictionary.parameters || {})[this.selectedParamName];
          if (!pDef) {
            this.$message.error('岻');
            return;
          }
          
          // 
          const modDef = (this.modelDictionary && this.modelDictionary.modules || {})[module.name];
          if (modDef && modDef.allowed_param_ids && pDef.id) {
            if (!modDef.allowed_param_ids.includes(pDef.id)) {
              this.$message.error(' ' + module.name + '  ' + this.selectedParamName + ' (ID: ' + pDef.id + ')');
              return;
            }
          }
          
          // 
          let initialValue;
          if (pDef.type === 'array') {
            initialValue = pDef.default !== undefined ? [...pDef.default] : [];
          } else if (pDef.type === 'matrix') {
            initialValue = pDef.default !== undefined ? pDef.default.map(row => [...row]) : [[0, 0, 0]];
          } else if (pDef.type === 'boolean') {
            initialValue = pDef.default !== undefined ? pDef.default : (pDef.options && pDef.options.length > 0 ? pDef.options[0] : 0);
          } else {
            initialValue = pDef.default !== undefined ? pDef.default : (pDef.min !== undefined ? pDef.min : 0);
          }
          
          const newParam = {
            name: this.selectedParamName,
            type: pDef.type || 'single',
            value: initialValue
          };
          
          // 
          if (!module.params) this.$set(module, 'params', []);
          module.params.push(newParam);
          this.hasModified = true;
          this.dialogAddParamVisible = false;
          
          this.$message.success(': ' + this.selectedParamName);
        },
        handleRemoveParam(moduleIndex, paramIndex) {
          if (!this.currentModel || !this.currentModel.modules || moduleIndex < 0) return;
          const module = this.currentModel.modules[moduleIndex];
          if (!module || !module.params || paramIndex < 0 || paramIndex >= module.params.length) return;
          
          // 
          if (this.isFileRunning(this.currentModel.filename) && this.runningModule === module.name) {
            this.$message.warning('');
            return;
          }
          
          const param = module.params[paramIndex];
          
          this.$confirm(' ' + module.name + '  ' + param.name + ' ', '', {
            confirmButtonText: '',
            cancelButtonText: '',
            type: 'info'
          }).then(() => {
            module.params.splice(paramIndex, 1);
            this.hasModified = true;
            this.$message.success(': ' + param.name);
          }).catch(() => {});
        },
        async handleDeleteModel(model, index) {
          // 
          if (this.isFileRunning(model.filename)) {
            this.$message.error('');
            return;
          }
          try {
            await this.$confirm(' ' + model.filename + ' ', '', {
              confirmButtonText: '',
              cancelButtonText: '',
              type: 'warning'
            });

            if (this.wsConnected && model.path) {
              await wsClient.deleteLocalFile(model.path);
              this.$message.success('');
              // 
              await this.parseAllFiles();
              if (this.activeModelIndex >= this.models.length) {
                this.activeModelIndex = Math.max(-1, this.models.length - 1);
              }
            } else {
              this.models.splice(index, 1);
              this.$message.success(' ()');
            }
          } catch (err) {
            if (err !== 'cancel') {
              this.$message.error(': ' + (err.message || err));
            }
          }
        },
        handleRemoveModule(index) {
          if (!this.currentModel || !this.currentModel.modules) return;
          const mod = this.currentModel.modules[index];
          
          // 
          if (this.isFileRunning(this.currentModel.filename) && this.runningModule === mod.name) {
            this.$message.error('');
            return;
          }

          this.$confirm(' ' + mod.name + ' ', '', {
            confirmButtonText: '',
            cancelButtonText: '',
            type: 'info'
          }).then(() => {
            this.currentModel.modules.splice(index, 1);
            this.hasModified = true;
            this.$message.success(': ' + mod.name);
          }).catch(() => {});
        },
        
        /**
         * 豸
         * WebSocket: apply_params_to_device
         */
        async handleApply() {
          if (!this.canApply || !this.currentModel || !this.currentModel.path) return;
          
          try {
            const content = this.generateBinContent();
            if (this.wsConnected) {
              await wsClient.applyParamsToDevice(this.device_id, this.loader_num, this.currentModel.path, content);
              this.$message.success('豸');
            } else {
              console.log('[] 豸:', this.currentModel.path);
              this.$message.success('豸 ()');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * 
         * WebSocket: upload_to_cloud
         */
        async handleUploadCloud() {
          if (!this.currentModel || !this.currentModel.path) return;
          
          try {
            if (this.wsConnected) {
              await wsClient.uploadToCloud(this.currentModel.path);
              this.$message.success('');
            } else {
              console.log('[] ');
              this.$message.success(' ()');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * 
         * WebSocket: cloud.list
         */
        async handleGetCloudList() {
          try {
            if (this.wsConnected) {
              const data = await wsClient.getCloudFileList(this.deviceSN);
              console.log(':', data.files);
              // TODO: 
              this.$message.success(' ' + data.files.length + ' ');
            } else {
              console.log('[] ');
              this.$message.info(' ()');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * 豸
         * WebSocket: load_model
         */
        /**
         * 豸
         * WebSocket: download_from_device
         */
        async handleDownloadDevice() {
          if (!this.currentModel) {
            this.$message.warning('');
            return;
          }
          
          try {
            const { value } = await this.$prompt('豸', '豸', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: this.currentModel.path || 'project1/example.bin'
            });
            
            if (this.wsConnected) {
              // 豸
              await wsClient.downloadFromDevice(this.device_id, this.loader_num, value, value);
              this.$message.success('豸');
              // 
              await this.parseAllFiles();
            } else {
              console.log('[] 豸');
              this.$message.success('豸 ()');
            }
          } catch (err) {
            if (err !== 'cancel') {
              this.$message.error(': ' + err.message);
            }
          }
        },
        
        /**
         * 豸
         * WebSocket: device.status
         */
        async refreshDeviceInfo() {
          try {
            // 
            this.syncDeviceInfoFromStatus();
            //  MFILE 
            await this.refreshDeviceInfoFromSignals();
            this.$message.success('豸');
          } catch (err) {
            console.error('豸:', err);
          }
        },
        
        /**
         * 
         * WebSocket: register.read
         * @param {Object} reg - 
         */
        async readRegister(reg, retryCount = 0) {
          if (!this.deviceConnected) {
            this.$message.warning('豸');
            return;
          }
          
          reg.loading = true;
          
          try {
            if (this.wsConnected) {
              const resp = await wsClient.waitRegValue(this.device_id, this.loader_num, reg.name);
              //  {data: {...}}  {...}
              let payload = resp;
              if (resp && typeof resp === 'object') {
                if (resp.data !== undefined) {
                  //  data 
                  if (typeof resp.data === 'string') {
                    try {
                      payload = JSON.parse(resp.data);
                    } catch (e) {
                      payload = resp.data;
                    }
                  } else {
                    payload = resp.data;
                  }
                }
              }
              
              // wait_reg_value  desc ret 
              if (payload && (payload.ret === true || payload.ret === 'true')) {
                const value = payload.desc !== undefined ? String(payload.desc) : '';
                
                // null3
                if ((value === '' || value === 'null' || value === 'Null' || value === 'NULL') && retryCount < 3) {
                  console.log('[Register] ' + reg.name + '  ' + (retryCount + 1) + '/3');
                  reg.loading = false;
                  await new Promise(resolve => setTimeout(resolve, 300)); // 300ms
                  return this.readRegister(reg, retryCount + 1);
                }
                
                reg.value = value;
                reg.readError = false;
                if (retryCount === 0) {
                  this.$message.success(' ' + reg.name + ' ');
                } else {
                  this.$message.success(' ' + reg.name + ' ' + retryCount + '');
                }
              } else {
                throw new Error(payload && payload.desc ? String(payload.desc) : '');
              }
            } else {
              // 
              console.log('[]  ' + reg.name);
              if (reg.type === 'int') {
                reg.value = Math.floor(Math.random() * 10000);
              } else {
                reg.value = reg.value || 'sample_string';
              }
              reg.readError = false;
              this.$message.success(' ' + reg.name + '  ()');
            }
          } catch (err) {
            // 3
            if (retryCount < 3) {
              console.log('[Register] ' + reg.name + '  ' + (retryCount + 1) + '/3: ' + err.message);
              reg.loading = false;
              await new Promise(resolve => setTimeout(resolve, 300)); // 300ms
              return this.readRegister(reg, retryCount + 1);
            }
            // "" UI 
            reg.value = '';
            reg.readError = true;
            this.$message.error(': ' + err.message);
          } finally {
            reg.loading = false;
          }
        },
        
        /**
         * 
         * WebSocket: register.write
         * @param {Object} reg - 
         */
        async writeRegister(reg) {
          if (!this.deviceConnected) {
            this.$message.warning('豸');
            return;
          }
          
          if (reg.inputValue === null || reg.inputValue === '') {
            this.$message.warning('');
            return;
          }
          
          const writeValue = reg.inputValue;
          
          try {
            if (this.wsConnected) {
              const resp = await wsClient.setRegValue(this.device_id, this.loader_num, reg.name, writeValue);
              const payload = (resp && resp.data !== undefined) ? resp.data : resp;
              if (payload && payload.ret === false) throw new Error(payload.desc || '');
              
              //  wait_reg_value 
              try {
                const readResp = await wsClient.waitRegValue(this.device_id, this.loader_num, reg.name);
                let readPayload = readResp;
                if (readResp && typeof readResp === 'object') {
                  if (readResp.data !== undefined) {
                    if (typeof readResp.data === 'string') {
                      try {
                        readPayload = JSON.parse(readResp.data);
                      } catch (e) {
                        readPayload = readResp.data;
                      }
                    } else {
                      readPayload = readResp.data;
                    }
                  }
                }
                
                if (readPayload && (readPayload.ret === true || readPayload.ret === 'true')) {
                  const actualValue = readPayload.desc !== undefined ? String(readPayload.desc) : '';
                  if (reg.access === 'readwrite' || reg.access === 'read') {
                    reg.value = actualValue;
                  }
                }
              } catch (readErr) {
                console.warn('[Register] :', readErr);
                // fallback
                if (reg.access === 'readwrite') {
                  reg.value = writeValue;
                }
              }
            } else {
              // 
              console.log('[]  0x' + reg.address.toString(16).toUpperCase() + ' = ' + writeValue);
              if (reg.access === 'readwrite') {
                reg.value = writeValue;
              }
            }
            
            reg.inputValue = null;
            reg.modified = true;
            
            this.$message.success(' ' + reg.name + ' ');
            
            // 3
            setTimeout(() => { reg.modified = false; }, 3000);
          } catch (err) {
            this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * 
         * WebSocket: register.readAll
         */
        async refreshAllRegisters() {
          if (!this.deviceConnected) {
            this.$message.warning('豸');
            return;
          }
          
          this.registerLoading = true;
          const readableRegs = this.registers.filter(r => r.access !== 'write');
          
          for (const reg of readableRegs) {
            reg.loading = true;
          }
          
          try {
            if (this.wsConnected) {
              const resp = await wsClient.getSignals(this.device_id, this.loader_num);
              // get_signals  [{name:"CCV", value:"100"}, ...]
              let list = [];
              if (Array.isArray(resp)) {
                list = resp;
              } else if (resp && typeof resp === 'object') {
                //  data 
                if (resp.data !== undefined) {
                  if (Array.isArray(resp.data)) {
                    list = resp.data;
                  } else if (typeof resp.data === 'string') {
                    try {
                      const parsed = JSON.parse(resp.data);
                      list = Array.isArray(parsed) ? parsed : [];
                    } catch (e) {
                      console.warn('[register] Failed to parse get_signals response:', e);
                    }
                  }
                } else if (Array.isArray(resp.list)) {
                  list = resp.list;
                }
              }
              
              const byName = new Map();
              for (const item of list) {
                if (item && item.name !== undefined && item.name !== null) {
                  byName.set(String(item.name), item.value !== undefined ? String(item.value) : '');
                }
              }
              
              const returned = new Set();
              for (const reg of readableRegs) {
                if (byName.has(reg.name)) {
                  reg.value = byName.get(reg.name);
                  reg.readError = false;
                  reg.loading = false;
                  returned.add(reg.name);
                }
              }
              // ""
              for (const reg of readableRegs) {
                if (!returned.has(reg.name)) {
                  reg.value = '';
                  reg.readError = true;
                  reg.loading = false;
                }
              }
              
              if (list.length > 0) {
                this.$message.success(' ' + returned.size + '/' + readableRegs.length + ' ');
              } else {
                this.$message.warning('豸');
              }
            } else {
              // 
              console.log('[] ');
              await new Promise(resolve => setTimeout(resolve, 500));
              for (const reg of readableRegs) {
                if (reg.type === 'int') {
                  reg.value = Math.floor(Math.random() * 10000);
                }
                reg.readError = false;
                reg.loading = false;
              }
              this.$message.success(' ()');
            }
          } catch (err) {
            this.$message.error(': ' + err.message);
            for (const reg of readableRegs) {
              reg.loading = false;
              reg.value = '';
              reg.readError = true;
            }
          } finally {
            this.registerLoading = false;
          }
        },

        // ============================================================
        // socket.md(9~13)  UI 
        // ============================================================
        async handleGetFileInfo() {
          try {
            const { value } = await this.$prompt('/', 'get_file_info', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: ''
            });
            const resp = await wsClient.getFileInfo(this.device_id, this.loader_num, value || '');
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            console.log('[get_file_info]', payload);
            this.$message.success(' console.log');
          } catch {
            // cancel
          }
        },
        handleLoadModelToDevice() {
          if (!this.currentModel || !this.currentModel.path) {
            this.$message.warning('');
            return;
          }
          // 豸
          this.importDeviceType = 'current';
          this.dialogImportDeviceVisible = true;
        },
        async confirmImportDevice() {
          if (!this.currentModel || !this.currentModel.path) return;
          
          try {
            // 浱
            if (this.hasModified) {
              await wsClient.saveLocalFile(this.currentModel.path, this.generateBinContent());
            }
            
            const project = this.currentModel.path.split('/')[0] || 'project1';
            const modelzip = this.currentModel.path;
            const allDevices = this.importDeviceType === 'all';
            
            let resp;
            if (allDevices) {
              // 豸 device_id  loader_num
              resp = await wsClient.loadModel(null, null, modelzip, project, true);
            } else {
              // 豸
              resp = await wsClient.loadModel(this.device_id, this.loader_num, modelzip, project, false);
            }
            
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) throw new Error(payload.desc || 'load_model failed');
            this.$message.success((payload && payload.desc) || ('' + (allDevices ? '豸' : '豸') + ''));
            this.dialogImportDeviceVisible = false;
          } catch (err) {
            this.$message.error(': ' + (err.message || err));
          }
        },
        async handleDownloadCloudModel() {
          try {
            const p1 = await this.$prompt(' project', 'download_cloud_models', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: 'project1'
            });
            const project = p1.value;
            const p2 = await this.$prompt(' model_name xxx.zip', 'download_cloud_models', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: 'example.zip'
            });
            const model_name = p2.value;
            const p3 = await this.$prompt(' model_id', 'download_cloud_models', {
              confirmButtonText: '',
              cancelButtonText: '',
              inputValue: '0',
              inputPattern: /^\d+$/,
              inputErrorMessage: 'model_id '
            });
            const model_id = Number(p3.value);
            const resp = await wsClient.downloadCloudModels(this.device_id, this.loader_num, model_name, model_id, project);
            const payload = (resp && resp.data !== undefined) ? resp.data : resp;
            if (payload && payload.ret === false) throw new Error(payload.desc || 'download_cloud_models failed');
            this.$message.success((payload && payload.desc) || '');
            // 
            await this.parseAllFiles();
          } catch (err) {
            if (err && err.message && err !== 'cancel') this.$message.error(': ' + err.message);
          }
        },
        
        /**
         * bin
         */
        generateBinContent() {
          if (!this.currentModel || !this.currentModel.modules) return '';
          let content = '';
          for (const mod of this.currentModel.modules) {
            content += mod.name + '\n';
            for (const param of mod.params) {
              if (param.type === 'matrix') {
                content += param.name + ':\n';
                for (const row of param.value) {
                  content += '    ' + row.join(' ') + '\n';
                }
              } else if (param.type === 'array') {
                content += param.name + ':' + param.value.join(' ') + '\n';
              } else {
                content += param.name + ':' + param.value + '\n';
              }
            }
            content += '\n';
          }
          return content;
        },
        
        // ============================================================
        // WebSocket 
        // ============================================================
        
        /**
         *  WebSocket 
         */
        initWebSocket() {
          const self = this;
          
          // 
          wsClient.on('connected', () => {
            self.wsConnected = true;
            self.$message.success('WebSocket ');
            //  +  + 
            self.loadLocationInfo();
            wsClient.startGetConnectStatus().catch(() => {});
            self.lastConnectStatusTime = Date.now(); // 
            self.hasRequestedConnectStatus = false; // 
            self.loadRegisterSheets(); //  Sheet 
            self.loadRegisterDefinitions()
              .then(() => self.refreshDeviceInfoFromSignals());
            
            //  get_connect_status 
            self.startConnectStatusMonitor();
          });

          wsClient.on('disconnected', () => {
            self.wsConnected = false;
            self.$message.warning('WebSocket ');
            // 
            self.stopConnectStatusMonitor();
            // 豸
            self.markAllDevicesAsDisconnected();
          });

          wsClient.on('reconnectFailed', () => {
            self.$message.error('WebSocket ');
          });

          wsClient.on('error', (err) => {
            console.error('[WS] :', err);
          });

          // socket.mdname=refresh_signals31
          wsClient.on('refresh_signals', (data) => {
            // 
            try {
              const signals = Array.isArray(data) ? data : (data && Array.isArray(data.data) ? data.data : []);
              if (signals.length > 0) {
                const m = self.signalsToMap(signals);
                // 
                const currentSheet = self.registerSheets.find(s => s.id === self.activeSheetId);
                if (currentSheet && self.activePage === 'register') {
                  const names = currentSheet.id === 'root' ? self.registers.map(r => r.name) : currentSheet.registerNames;
                  self.registers.forEach(reg => {
                    if (names.includes(reg.name) && m.has(reg.name)) {
                      reg.value = m.get(reg.name);
                      reg.readError = false;
                    }
                  });
                }
              }
            } catch (err) {
              console.warn('[UI] refresh_signals handler error:', err);
            }
          });

          // 豸
          wsClient.on('device.statusUpdate', (data) => {
            self.handleDeviceStatusUpdate(data);
          });

          // 仯
          wsClient.on('register.changed', (data) => {
            self.handleRegisterChanged(data);
          });

          //  loader /socket.mdname=get_connect_status
          wsClient.on('get_connect_status', (data) => {
            self.connectStatus = data || {};
            // 
            self.lastConnectStatusTime = Date.now();
            // 
            self.hasRequestedConnectStatus = false;
            
            // 豸
            try {
              if (!self.selectedDeviceKey) {
                // : { lab: [ { ip, port, value: [device,...] }, ... ] }
                const firstLab = self.connectStatus && typeof self.connectStatus === 'object' ? Object.values(self.connectStatus)[0] : null;
                const cabinets = Array.isArray(firstLab) ? firstLab : [];
                let found = false;
                
                for (const cab of cabinets) {
                  const devices = Array.isArray(cab.value) ? cab.value : [];
                  if (devices.length > 0) {
                    const d = devices[0];
                    if (d && d.ip !== undefined && d.loader_num !== undefined) {
                      self.device_id = String(d.ip);
                      self.loader_num = Number(d.loader_num);
                      self.selectedDeviceKey = String(d.ip) + '#' + Number(d.loader_num);
                      found = true;
                      break;
                    }
                  } else if (cab && cab.ip !== undefined && cab.loader_num !== undefined) {
                    // 
                    self.device_id = String(cab.ip);
                    self.loader_num = Number(cab.loader_num);
                    self.selectedDeviceKey = String(cab.ip) + '#' + Number(cab.loader_num);
                    found = true;
                    break;
                  }
                }
              }
            } catch (e) {
              console.warn('[UI] Auto-select failed:', e);
            }

            // 豸/
            try {
              const entry = self.currentDeviceEntry;
              if (entry) {
                self.deviceConnected = !!entry.connect;
                // 豸
                self.syncDeviceInfoFromStatus(entry);
              } else {
                self.deviceConnected = false;
                self.isModelRunning = false;
                self.runningFile = '';
              }
            } catch (e) {
              console.warn('[UI] Status sync failed:', e);
            }
          });

          // OTA socket.md 15
          wsClient.on('update_ota_progress', (data) => {
            try {
              const ip = data && (data.ip || data.device_id);
              const loader_num = data && data.loader_num;
              const p = Number(data && data.progress);
              if (ip === undefined || loader_num === undefined) return;
              const k = self.otaKey(ip, loader_num);
              if (Number.isFinite(p)) self.$set(self.otaProgress, k, p);
              self.$set(self.otaStatus, k, { status: 'running', desc: ' ' + (Number.isFinite(p) ? p.toFixed(1) : '') + '%' });
            } catch (e) {}
          });

          // OTA  name=update_loaders
          wsClient.on('update_loaders', (data) => {
            try {
              const ip = data && (data.ip || data.device_id);
              const loader_num = data && data.loader_num;
              if (ip === undefined || loader_num === undefined) return;
              const k = self.otaKey(ip, loader_num);
              const st = data && data.loader_ota_status ? String(data.loader_ota_status) : '';
              const ok = st.toLowerCase() === 'success';
              self.$set(self.otaProgress, k, ok ? 100 : (self.otaProgress[k] || 0));
              self.$set(self.otaStatus, k, { status: ok ? 'success' : 'error', desc: (data && data.desc) || st || (ok ? 'success' : 'failed') });
              // 
              if (self.otaUpdatingKey === k) {
                self.otaUpdatingKey = '';
              }
            } catch (e) {}
          });

          // 
          wsClient.connect().catch(err => {
            console.log('[WS] ');
          });
        },
        
        /**
         *  get_connect_status 
         * 1010
         */
        startConnectStatusMonitor() {
          this.stopConnectStatusMonitor(); // 
          
          this.connectStatusCheckTimer = setInterval(() => {
            this.checkConnectStatus();
          }, 10000); // 10
        },
        
        /**
         *  get_connect_status 
         */
        stopConnectStatusMonitor() {
          if (this.connectStatusCheckTimer) {
            clearInterval(this.connectStatusCheckTimer);
            this.connectStatusCheckTimer = null;
          }
        },
        
        /**
         *  get_connect_status 
         * 10
         */
        async checkConnectStatus() {
          if (!this.wsConnected) return;
          
          const now = Date.now();
          const timeSinceLastMessage = now - this.lastConnectStatusTime;
          
          // 10
          if (timeSinceLastMessage > 10000 && !this.hasRequestedConnectStatus) {
            console.log('[WS] get_connect_status ');
            this.hasRequestedConnectStatus = true;
            try {
              await wsClient.startGetConnectStatus();
              // 3
              setTimeout(() => {
                const stillTimeout = Date.now() - this.lastConnectStatusTime > 13000;
                if (stillTimeout && this.wsConnected) {
                  console.warn('[WS] get_connect_status 豸');
                  this.markAllDevicesAsDisconnected();
                }
              }, 3000);
            } catch (err) {
              console.error('[WS] get_connect_status :', err);
              this.markAllDevicesAsDisconnected();
            }
          }
        },
        
        /**
         * 豸
         */
        markAllDevicesAsDisconnected() {
          //  connectStatus豸 connect  false
          if (this.connectStatus && typeof this.connectStatus === 'object') {
            const updatedStatus = {};
            for (const [labKey, cabinets] of Object.entries(this.connectStatus)) {
              updatedStatus[labKey] = cabinets.map(cab => {
                if (Array.isArray(cab.value)) {
                  //  value 
                  return {
                    ...cab,
                    value: cab.value.map(dev => ({
                      ...dev,
                      connect: false
                    }))
                  };
                } else {
                  // 豸
                  return {
                    ...cab,
                    connect: false
                  };
                }
              });
            }
            this.connectStatus = updatedStatus;
          }
          
          // 豸
          const entry = this.currentDeviceEntry;
          if (entry) {
            this.deviceConnected = false;
            this.isModelRunning = false;
            this.runningFile = '';
          }
        },

        /**
         * 豸
         */
        handleDeviceStatusUpdate(data) {
          if (data.connected !== undefined) this.deviceConnected = data.connected;
          if (data.running_file) this.runningFile = data.running_file;
          if (data.running_module) this.runningModule = data.running_module;
          if (data.current !== undefined) this.realtimeData.current = data.current;
          if (data.voltage !== undefined) this.realtimeData.voltage = data.voltage;
          if (data.power !== undefined) this.realtimeData.power = data.power;
          if (data.temperature !== undefined) this.realtimeData.temperature = data.temperature;
        },

        /**
         * 仯
         */
        handleRegisterChanged(data) {
          const reg = this.registers.find(r => r.address === data.address);
          if (reg) {
            reg.value = data.value;
            reg.modified = true;
            setTimeout(() => { reg.modified = false; }, 3000);
          }
        },

        /**
         * WebSocket
         */
        async wsRequest(action, fallback) {
          if (this.wsConnected) {
            try {
              return await wsClient.request(action.name, action.params);
            } catch (err) {
              console.error('[WS] :', err);
              this.$message.error(': ' + err.message);
              throw err;
            }
          } else {
            // 
            console.log('[] ' + action.name, action.params);
            return fallback ? fallback() : { success: true };
          }
        }
      },
      mounted() {
        // 
        this.loadModelDictionary().finally(() => this.parseAllFiles());
        const runningIndex = this.models.findIndex(m => m.filename === this.runningFile);
        if (runningIndex !== -1) this.selectModel(runningIndex);
        
        //  WebSocket 
        this.initWebSocket();

        //  WebSocket  HTTP 
        this.loadRegisterDefinitions();

        // 
        //  WS 
        this.refreshModelOptions();

        // 豸
        this.loadDeviceSpecsConfig();
        
        //  get_connect_status
        window.addEventListener('beforeunload', () => {
          if (this.wsConnected) {
            // 
            wsClient.startGetConnectStatus().catch(() => {});
            //  stop_all_timers 
            wsClient.stopAllTimers().catch(() => {});
          }
          // 
          this.stopConnectStatusMonitor();
        });
      },
      beforeDestroy() {
        // 
        this.stopConnectStatusMonitor();
        //  stop_all_timers 
        if (this.wsConnected) {
          wsClient.stopAllTimers().catch(() => {});
        }
      }
    });</script><script src="js/chunk-vendors.892de51e.js"></script><script src="js/app.dbff47d4.js"></script></body></html>